<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation - Le Produit Scalaire</title>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global',
                scale: 1.2
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    window.MathJaxReady = true;
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>
    <style>
/* === main.css === */

/* ==============================================
   VARIABLES CSS GLOBALES
   ============================================== */
:root {
    /* Couleurs principales */
    --color-primary: #2563eb;
    --color-primary-dark: #1d4ed8;
    --color-primary-light: #3b82f6;
    --color-secondary: #7c3aed;
    --color-accent: #f59e0b;
    --color-success: #10b981;
    --color-error: #ef4444;
    --color-warning: #f59e0b;

    /* Couleurs de fond */
    --bg-main: #0f172a;
    --bg-panel: #1e293b;
    --bg-canvas: #ffffff;
    --bg-overlay: rgba(0, 0, 0, 0.7);
    --bg-glass: rgba(30, 41, 59, 0.95);

    /* Couleurs de texte */
    --text-primary: #f1f5f9;
    --text-secondary: #94a3b8;
    --text-muted: #64748b;
    --text-inverse: #1e293b;

    /* Bordures */
    --border-color: #334155;
    --border-radius: 8px;
    --border-radius-lg: 12px;

    /* Ombres */
    --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
    --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);
    --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.5);

    /* Dimensions */
    --menubar-height: 48px;
    --timeline-height: 60px;
    --scenes-height: 44px;

    /* Typographie */
    --font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    --font-mono: 'Consolas', 'Monaco', monospace;
    --font-size-sm: 13px;
    --font-size-base: 15px;
    --font-size-lg: 17px;
    --font-size-xl: 20px;
    --font-size-2xl: 24px;

    /* Transitions */
    --transition-fast: 150ms ease;
    --transition-normal: 250ms ease;
    --transition-slow: 400ms ease;
}

/* ==============================================
   RESET ET BASE
   ============================================== */
*, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html {
    font-size: var(--font-size-base);
}

body {
    font-family: var(--font-family);
    background: var(--bg-main);
    color: var(--text-primary);
    line-height: 1.5;
    min-height: 100vh;
    overflow: hidden;
}

/* ==============================================
   BARRE DE MENU
   ============================================== */
.menubar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: var(--menubar-height);
    background: var(--bg-panel);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 1rem;
    z-index: 1000;
}

.menu-left {
    display: flex;
    align-items: center;
}

.app-title {
    font-size: var(--font-size-lg);
    font-weight: 600;
    color: var(--text-primary);
}

.menu-center {
    display: flex;
    gap: 4px;
    background: var(--bg-main);
    padding: 4px;
    border-radius: var(--border-radius);
}

.menu-tab {
    padding: 0.5rem 1rem;
    font-size: var(--font-size-sm);
    font-weight: 500;
    border: none;
    background: transparent;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 6px;
    transition: all var(--transition-fast);
}

.menu-tab:hover {
    color: var(--text-primary);
}

.menu-tab.active {
    background: var(--color-primary);
    color: white;
}

.menu-right {
    display: flex;
    gap: 0.5rem;
}

.menu-btn {
    width: 36px;
    height: 36px;
    border: 1px solid var(--border-color);
    background: transparent;
    border-radius: var(--border-radius);
    font-size: var(--font-size-lg);
    color: var(--text-secondary);
    cursor: pointer;
    transition: all var(--transition-fast);
    display: flex;
    align-items: center;
    justify-content: center;
}

.menu-btn:hover {
    background: var(--border-color);
    color: var(--text-primary);
    border-color: var(--color-primary);
}

/* ==============================================
   CONTENEUR PRINCIPAL
   ============================================== */
.main-container {
    height: calc(100vh - var(--menubar-height));
    margin-top: var(--menubar-height);
    position: relative;
}

.mode-container {
    display: none;
    width: 100%;
    height: 100%;
    flex-direction: column;
}

.mode-container.active {
    display: flex;
}

.canvas-wrapper {
    flex: 1;
    position: relative;
    background: var(--bg-canvas);
    overflow: hidden;
}

.canvas-wrapper canvas {
    width: 100%;
    height: 100%;
    display: block;
}

/* ==============================================
   MODAL
   ============================================== */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--bg-overlay);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
}

.modal.hidden {
    display: none;
}

.modal-content {
    background: var(--bg-panel);
    border-radius: var(--border-radius-lg);
    max-width: 500px;
    width: 90%;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: var(--shadow-lg);
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.25rem;
    border-bottom: 1px solid var(--border-color);
}

.modal-header h2 {
    font-size: var(--font-size-lg);
    color: var(--text-primary);
}

.modal-close {
    width: 32px;
    height: 32px;
    border: none;
    background: transparent;
    font-size: var(--font-size-xl);
    cursor: pointer;
    color: var(--text-muted);
    transition: color var(--transition-fast);
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-close:hover {
    color: var(--color-error);
}

.modal-body {
    padding: 1.25rem;
    overflow-y: auto;
    max-height: calc(80vh - 60px);
    font-size: var(--font-size-base);
    line-height: 1.7;
}

.modal-body h3 {
    color: var(--color-primary-light);
    margin: 1rem 0 0.5rem;
    font-size: var(--font-size-lg);
}

.modal-body h3:first-child {
    margin-top: 0;
}

.modal-body ul {
    margin-left: 1.5rem;
    margin-bottom: 1rem;
}

.modal-body li {
    margin-bottom: 0.25rem;
}

.modal-body strong {
    color: var(--color-primary-light);
    font-family: var(--font-mono);
}

/* ==============================================
   UTILITAIRES
   ============================================== */
.hidden {
    display: none !important;
}

/* ==============================================
   PLEIN ÉCRAN
   ============================================== */
:fullscreen {
    background: var(--bg-main);
}

:fullscreen .menubar {
    height: 40px;
}

:fullscreen .main-container {
    height: calc(100vh - 40px);
    margin-top: 40px;
}

/* ==============================================
   OVERLAY MATHJAX
   ============================================== */
.math-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 10;
}

.math-overlay .math-element {
    position: absolute;
    transform: translate(-50%, -50%);
    transition: opacity 0.3s ease, transform 0.3s ease;
    pointer-events: auto;
}

.math-overlay .math-element.fade-in {
    animation: mathFadeIn 0.4s ease forwards;
}

.math-overlay .math-element.fade-out {
    animation: mathFadeOut 0.3s ease forwards;
}

@keyframes mathFadeIn {
    from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}

@keyframes mathFadeOut {
    from {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    to {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
    }
}

/* ==============================================
   RESULT BOX
   ============================================== */
.result-box {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 10px;
    padding: 12px 20px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    border: 2px solid currentColor;
    backdrop-filter: blur(5px);
}

.result-box.highlight {
    animation: resultPulse 0.5s ease;
}

@keyframes resultPulse {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.05); }
}

.result-box .math-content {
    font-size: 1.4em;
    font-weight: bold;
}

/* ==============================================
   TRANSITIONS ENTRE SCÈNES
   ============================================== */
.scene-transition {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.98);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 20;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
}

.scene-transition.active {
    opacity: 1;
    pointer-events: auto;
}

.scene-transition.hidden {
    display: none;
}

.scene-transition .transition-content {
    text-align: center;
}

.scene-transition .scene-title {
    font-size: 28px;
    font-weight: bold;
    color: var(--color-primary);
    margin-bottom: 10px;
}

.scene-transition .scene-subtitle {
    font-size: 18px;
    color: var(--text-muted);
}

/* Animation de fondu pour les éléments canvas */
.canvas-wrapper.transitioning canvas {
    animation: canvasFade 0.5s ease;
}

@keyframes canvasFade {
    0% { opacity: 1; }
    50% { opacity: 0.3; }
    100% { opacity: 1; }
}

/* ==============================================
   RESPONSIVE
   ============================================== */
@media (min-width: 1920px) {
    :root {
        --font-size-base: 16px;
        --font-size-lg: 18px;
        --font-size-xl: 22px;
    }
}


/* === interactive.css === */

/* ==============================================
   MODE INTERACTIF - BULLE DÉPLIABLE
   Style minimaliste pour exploration libre
   ============================================== */

/* ==============================================
   BULLE DE CONTRÔLES
   ============================================== */
.controls-bubble {
    position: absolute;
    top: 1rem;
    right: 1rem;
    z-index: 100;
}

/* Bouton toggle (toujours visible) */
.bubble-toggle {
    width: 48px;
    height: 48px;
    border: none;
    background: var(--bg-glass);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: var(--shadow-md);
    transition: all var(--transition-fast);
}

.bubble-toggle:hover {
    background: var(--bg-panel);
    transform: scale(1.05);
}

.bubble-icon {
    font-size: 22px;
    color: var(--text-primary);
    transition: transform var(--transition-normal);
}

.controls-bubble:not(.collapsed) .bubble-icon {
    transform: rotate(90deg);
}

/* Contenu de la bulle */
.bubble-content {
    position: absolute;
    top: 0;
    right: 0;
    width: 280px;
    background: var(--bg-glass);
    border-radius: var(--border-radius-lg);
    box-shadow: var(--shadow-lg);
    overflow: hidden;
    transform-origin: top right;
    transition: all var(--transition-normal);
}

.controls-bubble.collapsed .bubble-content {
    opacity: 0;
    transform: scale(0.9);
    pointer-events: none;
}

.controls-bubble:not(.collapsed) .bubble-toggle {
    opacity: 0;
    pointer-events: none;
}

/* Header de la bulle */
.bubble-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1rem;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-panel);
}

.bubble-header span {
    font-weight: 600;
    font-size: var(--font-size-base);
    color: var(--text-primary);
}

.bubble-close {
    width: 28px;
    height: 28px;
    border: none;
    background: transparent;
    color: var(--text-muted);
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: all var(--transition-fast);
}

.bubble-close:hover {
    background: var(--border-color);
    color: var(--text-primary);
}

/* Corps de la bulle */
.bubble-body {
    padding: 0.75rem;
    max-height: 60vh;
    overflow-y: auto;
}

.bubble-body::-webkit-scrollbar {
    width: 6px;
}

.bubble-body::-webkit-scrollbar-track {
    background: transparent;
}

.bubble-body::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 3px;
}

/* ==============================================
   SECTIONS DE CONTRÔLES
   ============================================== */
.control-section {
    margin-bottom: 0.5rem;
}

.control-section:last-child {
    margin-bottom: 0;
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0.75rem;
    background: var(--bg-main);
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: var(--font-size-sm);
    font-weight: 500;
    color: var(--text-secondary);
    transition: all var(--transition-fast);
}

.section-header:hover {
    color: var(--text-primary);
}

.section-toggle {
    font-size: 10px;
    transition: transform var(--transition-fast);
}

.control-section.collapsed .section-toggle {
    transform: rotate(-90deg);
}

.section-content {
    padding: 0.75rem;
    display: block;
}

.control-section.collapsed .section-content {
    display: none;
}

/* ==============================================
   CONTRÔLES
   ============================================== */
.control-group {
    margin-bottom: 0.75rem;
}

.control-group:last-child {
    margin-bottom: 0;
}

.control-label {
    display: block;
    font-size: var(--font-size-sm);
    color: var(--text-secondary);
    margin-bottom: 0.35rem;
}

/* Checkbox */
.checkbox-control {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 0;
    cursor: pointer;
    font-size: var(--font-size-sm);
    color: var(--text-primary);
}

.checkbox-control input[type="checkbox"] {
    width: 18px;
    height: 18px;
    accent-color: var(--color-primary);
    cursor: pointer;
}

.checkbox-control:hover {
    color: var(--color-primary-light);
}

/* Slider */
.slider-control {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
}

.slider-control input[type="range"] {
    width: 100%;
    height: 6px;
    background: var(--border-color);
    border-radius: 3px;
    outline: none;
    cursor: pointer;
    -webkit-appearance: none;
}

.slider-control input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    background: var(--color-primary);
    border-radius: 50%;
    cursor: pointer;
}

.slider-value {
    font-family: var(--font-mono);
    font-size: var(--font-size-sm);
    color: var(--color-primary-light);
    text-align: right;
}

/* Select */
.select-control select {
    width: 100%;
    padding: 0.5rem 0.75rem;
    font-size: var(--font-size-sm);
    font-family: inherit;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    background: var(--bg-main);
    color: var(--text-primary);
    cursor: pointer;
    outline: none;
}

.select-control select:focus {
    border-color: var(--color-primary);
}

/* Number input */
.number-control input[type="number"] {
    width: 100%;
    padding: 0.5rem 0.75rem;
    font-size: var(--font-size-sm);
    font-family: var(--font-mono);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    background: var(--bg-main);
    color: var(--text-primary);
    outline: none;
}

.number-control input[type="number"]:focus {
    border-color: var(--color-primary);
}

/* ==============================================
   OVERLAY D'INFORMATIONS
   ============================================== */
.info-overlay {
    position: absolute;
    bottom: 1rem;
    left: 1rem;
    background: var(--bg-glass);
    border-radius: var(--border-radius);
    padding: 0.75rem 1rem;
    min-width: 180px;
    max-width: 300px;
    box-shadow: var(--shadow-md);
}

.info-overlay:empty {
    display: none;
}

.info-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.3rem 0;
    font-size: var(--font-size-sm);
    border-bottom: 1px solid var(--border-color);
}

.info-item:last-child {
    border-bottom: none;
}

.info-item .label {
    color: var(--text-secondary);
}

.info-item .value {
    font-family: var(--font-mono);
    color: var(--color-primary-light);
    font-weight: 500;
}

/* Valeurs colorées selon le contexte */
.info-item .value.positive {
    color: var(--color-success);
}

.info-item .value.negative {
    color: var(--color-error);
}

.info-item .value.zero {
    color: var(--color-accent);
}

/* ==============================================
   INSTRUCTIONS AU SURVOL
   ============================================== */
.hover-hint {
    position: absolute;
    bottom: 1rem;
    right: 1rem;
    background: var(--bg-glass);
    padding: 0.5rem 0.75rem;
    border-radius: var(--border-radius);
    font-size: var(--font-size-sm);
    color: var(--text-muted);
    opacity: 0;
    transition: opacity var(--transition-normal);
    pointer-events: none;
}

.canvas-wrapper:hover .hover-hint {
    opacity: 1;
}

/* ==============================================
   RESPONSIVE
   ============================================== */
@media (max-width: 768px) {
    .controls-bubble {
        top: 0.5rem;
        right: 0.5rem;
    }

    .bubble-toggle {
        width: 44px;
        height: 44px;
    }

    .bubble-content {
        width: 260px;
    }

    .info-overlay {
        bottom: 0.5rem;
        left: 0.5rem;
        font-size: var(--font-size-sm);
    }
}


/* === timeline.css === */

/* ==============================================
   MODE ANIMATION - TIMELINE
   Style lecteur vidéo pour animations séquentielles
   ============================================== */

/* ==============================================
   BARRE TIMELINE
   ============================================== */
.timeline-bar {
    height: var(--timeline-height);
    background: var(--bg-panel);
    border-top: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    padding: 0 1rem;
    gap: 1rem;
}

/* ==============================================
   CONTRÔLES DE LECTURE
   ============================================== */
.timeline-controls {
    display: flex;
    align-items: center;
    gap: 4px;
}

.tl-btn {
    width: 36px;
    height: 36px;
    border: none;
    background: transparent;
    color: var(--text-secondary);
    font-size: 14px;
    cursor: pointer;
    border-radius: var(--border-radius);
    transition: all var(--transition-fast);
    display: flex;
    align-items: center;
    justify-content: center;
}

.tl-btn:hover {
    background: var(--border-color);
    color: var(--text-primary);
}

.tl-btn:active {
    transform: scale(0.95);
}

.tl-btn-play {
    width: 44px;
    height: 44px;
    background: var(--color-primary);
    color: white;
    font-size: 18px;
    border-radius: 50%;
}

.tl-btn-play:hover {
    background: var(--color-primary-dark);
    color: white;
}

.tl-btn-play.playing {
    background: var(--color-accent);
}

/* ==============================================
   BARRE DE PROGRESSION
   ============================================== */
.timeline-progress {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 1rem;
}

.progress-bar {
    flex: 1;
    height: 6px;
    background: var(--border-color);
    border-radius: 3px;
    position: relative;
    cursor: pointer;
}

.progress-bar:hover {
    height: 8px;
}

.progress-fill {
    height: 100%;
    background: var(--color-primary);
    border-radius: 3px;
    width: 0%;
    transition: width 50ms linear;
}

.progress-handle {
    position: absolute;
    top: 50%;
    left: 0%;
    transform: translate(-50%, -50%);
    width: 14px;
    height: 14px;
    background: white;
    border: 2px solid var(--color-primary);
    border-radius: 50%;
    cursor: grab;
    opacity: 0;
    transition: opacity var(--transition-fast);
}

.progress-bar:hover .progress-handle {
    opacity: 1;
}

.progress-handle:active {
    cursor: grabbing;
    transform: translate(-50%, -50%) scale(1.2);
}

/* Marqueurs de scènes sur la timeline */
.scene-marker {
    position: absolute;
    top: -2px;
    width: 2px;
    height: 10px;
    background: var(--text-muted);
    border-radius: 1px;
    transform: translateX(-50%);
}

.scene-marker:hover {
    background: var(--color-accent);
}

/* ==============================================
   AFFICHAGE DU TEMPS
   ============================================== */
.time-display {
    font-family: var(--font-mono);
    font-size: var(--font-size-sm);
    color: var(--text-secondary);
    min-width: 90px;
    text-align: right;
}

.time-display span:first-child {
    color: var(--text-primary);
}

/* ==============================================
   CONTRÔLE DE VITESSE
   ============================================== */
.timeline-speed {
    display: flex;
    gap: 2px;
    background: var(--bg-main);
    padding: 3px;
    border-radius: var(--border-radius);
}

.speed-btn {
    padding: 0.35rem 0.6rem;
    font-size: var(--font-size-sm);
    font-weight: 500;
    border: none;
    background: transparent;
    color: var(--text-muted);
    cursor: pointer;
    border-radius: 5px;
    transition: all var(--transition-fast);
}

.speed-btn:hover {
    color: var(--text-primary);
}

.speed-btn.active {
    background: var(--color-primary);
    color: white;
}

/* ==============================================
   BARRE DES SCÈNES/CHAPITRES
   ============================================== */
.scenes-bar {
    height: var(--scenes-height);
    background: var(--bg-main);
    border-top: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    padding: 0 1rem;
    gap: 0.5rem;
    overflow-x: auto;
}

.scenes-bar::-webkit-scrollbar {
    height: 4px;
}

.scenes-bar::-webkit-scrollbar-track {
    background: transparent;
}

.scenes-bar::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 2px;
}

.scene-btn {
    padding: 0.4rem 0.8rem;
    font-size: var(--font-size-sm);
    font-weight: 500;
    border: 1px solid var(--border-color);
    background: var(--bg-panel);
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: var(--border-radius);
    white-space: nowrap;
    transition: all var(--transition-fast);
}

.scene-btn:hover {
    border-color: var(--color-primary);
    color: var(--text-primary);
}

.scene-btn.active {
    background: var(--color-primary);
    border-color: var(--color-primary);
    color: white;
}

.scene-btn.completed {
    border-color: var(--color-success);
    color: var(--color-success);
}

.scene-btn.completed::before {
    content: '✓ ';
}

/* ==============================================
   INDICATEUR DE CHARGEMENT
   ============================================== */
.loading-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
}

.loading-spinner {
    width: 48px;
    height: 48px;
    border: 4px solid var(--border-color);
    border-top-color: var(--color-primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.loading-text {
    color: var(--text-secondary);
    font-size: var(--font-size-base);
}

/* ==============================================
   OVERLAY D'INFO PENDANT L'ANIMATION
   ============================================== */
.animation-info {
    position: absolute;
    bottom: 1rem;
    left: 1rem;
    background: var(--bg-glass);
    padding: 0.75rem 1rem;
    border-radius: var(--border-radius);
    font-size: var(--font-size-base);
    color: var(--text-primary);
    max-width: 400px;
    opacity: 0;
    transform: translateY(10px);
    transition: all var(--transition-normal);
    pointer-events: none;
}

.animation-info.visible {
    opacity: 1;
    transform: translateY(0);
}

.animation-info .info-title {
    font-weight: 600;
    color: var(--color-primary-light);
    margin-bottom: 0.25rem;
}

.animation-info .info-text {
    color: var(--text-secondary);
    font-size: var(--font-size-sm);
}

/* ==============================================
   RESPONSIVE
   ============================================== */
@media (max-width: 768px) {
    .timeline-bar {
        flex-wrap: wrap;
        height: auto;
        padding: 0.75rem;
        gap: 0.75rem;
    }

    .timeline-controls {
        order: 1;
    }

    .timeline-progress {
        order: 3;
        width: 100%;
    }

    .timeline-speed {
        order: 2;
    }

    .scenes-bar {
        height: auto;
        padding: 0.5rem;
        flex-wrap: wrap;
    }
}

    </style>
</head>
<body>
<!-- ============================================
         BARRE DE MENU PRINCIPALE
         ============================================ -->
    <nav class="menubar">
        <div class="menu-left">
            <span class="app-title">Le Produit Scalaire</span>
        </div>
        <div class="menu-center">
            <span class="menu-title">Animation</span>
        </div>
        <div class="menu-right">
            <button id="btn-fullscreen" class="menu-btn" title="Plein écran">⛶</button>
            <button id="btn-reset" class="menu-btn" title="Réinitialiser">↺</button>
            <button id="btn-help" class="menu-btn" title="Aide">?</button>
        </div>
    </nav>

    <!-- ============================================
         CONTENEUR PRINCIPAL
         ============================================ -->
    <main class="main-container">

        <!-- ========================================
             MODE ANIMATION (Capsule vidéo)
             ======================================== -->
        <div class="mode-container active" id="mode-animation">
            <div class="canvas-wrapper">
                <canvas id="animation-canvas"></canvas>
                <!-- Overlay pour le rendu MathJax -->
                <div id="math-overlay" class="math-overlay"></div>
                <!-- Overlay de transition entre scènes -->
                <div id="scene-transition" class="scene-transition hidden">
                    <div class="transition-content"></div>
                </div>
            </div>

            <!-- Barre de contrôle timeline -->
            <div class="timeline-bar">
                <div class="timeline-controls">
                    <button class="tl-btn" id="tl-prev-scene" title="Scène précédente">⏮</button>
                    <button class="tl-btn" id="tl-step-back" title="Reculer">◀◀</button>
                    <button class="tl-btn tl-btn-play" id="tl-play" title="Lecture/Pause">▶</button>
                    <button class="tl-btn" id="tl-step-forward" title="Avancer">▶▶</button>
                    <button class="tl-btn" id="tl-next-scene" title="Scène suivante">⏭</button>
                </div>

                <div class="timeline-progress">
                    <div class="progress-bar" id="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                        <div class="progress-handle" id="progress-handle"></div>
                        <!-- Marqueurs de scènes ajoutés dynamiquement -->
                    </div>
                    <div class="time-display">
                        <span id="time-current">0:00</span>
                        <span>/</span>
                        <span id="time-total">0:00</span>
                    </div>
                </div>

                <div class="timeline-speed">
                    <button class="speed-btn" data-speed="0.5">0.5x</button>
                    <button class="speed-btn active" data-speed="1">1x</button>
                    <button class="speed-btn" data-speed="2">2x</button>
                </div>
            </div>

            <!-- Chapitres/Scènes -->
            <div class="scenes-bar" id="scenes-bar">
                <!-- Boutons de scènes générés dynamiquement -->
            </div>
        </div>

    </main>

    <!-- ============================================
         MODAL D'AIDE
         ============================================ -->
    <div class="modal hidden" id="help-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Aide</h2>
                <button class="modal-close" id="modal-close">×</button>
            </div>
            <div class="modal-body" id="help-content">
                <h3>Controles</h3>
                <p>Utilisez les controles pour naviguer dans l'animation :</p>
                <ul>
                    <li><strong>▶/⏸</strong> : Lecture/Pause</li>
                    <li><strong>◀◀/▶▶</strong> : Reculer/Avancer</li>
                    <li><strong>⏮/⏭</strong> : Scene precedente/suivante</li>
                    <li><strong>Barre de progression</strong> : Cliquez pour naviguer</li>
                    <li><strong>Chapitres</strong> : Cliquez pour aller a une scene</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- ============================================
         SCRIPTS
         ============================================ -->
    <!-- Core -->
    <!-- Scènes (dans js/scenarios/) -->
    <!-- Chargement des scènes et démarrage -->
    <script>
// === math-utils.js ===

/**
 * UTILITAIRES MATHÉMATIQUES
 * Fonctions de haute précision pour les calculs mathématiques
 *
 * IMPORTANT: Toutes les fonctions utilisent une précision contrôlée
 * pour éviter les erreurs d'arrondi flottant.
 */

const MathUtils = {
    // ==========================================
    // CONSTANTES
    // ==========================================
    PI: Math.PI,
    TAU: 2 * Math.PI,
    E: Math.E,
    SQRT2: Math.SQRT2,
    SQRT3: Math.sqrt(3),
    PHI: (1 + Math.sqrt(5)) / 2, // Nombre d'or

    // Précision par défaut pour les arrondis
    DEFAULT_PRECISION: 10,

    // Tolérance pour les comparaisons
    EPSILON: 1e-10,

    // ==========================================
    // FONCTIONS DE BASE AVEC PRÉCISION
    // ==========================================

    /**
     * Arrondit un nombre à n décimales
     */
    round(value, decimals = this.DEFAULT_PRECISION) {
        const factor = Math.pow(10, decimals);
        return Math.round(value * factor) / factor;
    },

    /**
     * Vérifie si deux nombres sont égaux (avec tolérance)
     */
    equals(a, b, epsilon = this.EPSILON) {
        return Math.abs(a - b) < epsilon;
    },

    /**
     * Vérifie si un nombre est proche de zéro
     */
    isZero(value, epsilon = this.EPSILON) {
        return Math.abs(value) < epsilon;
    },

    /**
     * Signe d'un nombre (-1, 0, 1)
     */
    sign(value) {
        if (this.isZero(value)) return 0;
        return value > 0 ? 1 : -1;
    },

    /**
     * Clamp une valeur entre min et max
     */
    clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    },

    /**
     * Interpolation linéaire
     */
    lerp(a, b, t) {
        return a + (b - a) * t;
    },

    /**
     * Inverse de l'interpolation linéaire
     */
    inverseLerp(a, b, value) {
        if (this.equals(a, b)) return 0;
        return (value - a) / (b - a);
    },

    /**
     * Map une valeur d'un intervalle à un autre
     */
    map(value, inMin, inMax, outMin, outMax) {
        return this.lerp(outMin, outMax, this.inverseLerp(inMin, inMax, value));
    },

    // ==========================================
    // TRIGONOMÉTRIE
    // ==========================================

    /**
     * Convertit degrés en radians
     */
    degToRad(degrees) {
        return degrees * (this.PI / 180);
    },

    /**
     * Convertit radians en degrés
     */
    radToDeg(radians) {
        return radians * (180 / this.PI);
    },

    /**
     * Sinus avec précision
     */
    sin(angle, inDegrees = false) {
        const rad = inDegrees ? this.degToRad(angle) : angle;
        return this.round(Math.sin(rad));
    },

    /**
     * Cosinus avec précision
     */
    cos(angle, inDegrees = false) {
        const rad = inDegrees ? this.degToRad(angle) : angle;
        return this.round(Math.cos(rad));
    },

    /**
     * Tangente avec précision
     */
    tan(angle, inDegrees = false) {
        const rad = inDegrees ? this.degToRad(angle) : angle;
        return this.round(Math.tan(rad));
    },

    /**
     * Arc sinus
     */
    asin(value) {
        return this.round(Math.asin(this.clamp(value, -1, 1)));
    },

    /**
     * Arc cosinus
     */
    acos(value) {
        return this.round(Math.acos(this.clamp(value, -1, 1)));
    },

    /**
     * Arc tangente
     */
    atan(value) {
        return this.round(Math.atan(value));
    },

    /**
     * Arc tangente 2 (angle d'un point)
     */
    atan2(y, x) {
        return this.round(Math.atan2(y, x));
    },

    /**
     * Normalise un angle en radians dans [0, 2π)
     */
    normalizeAngle(angle) {
        angle = angle % this.TAU;
        if (angle < 0) angle += this.TAU;
        return this.round(angle);
    },

    /**
     * Normalise un angle en degrés dans [0, 360)
     */
    normalizeAngleDeg(angle) {
        angle = angle % 360;
        if (angle < 0) angle += 360;
        return this.round(angle);
    },

    // ==========================================
    // VECTEURS 2D
    // ==========================================

    /**
     * Crée un vecteur 2D
     */
    vec2(x = 0, y = 0) {
        return { x, y };
    },

    /**
     * Addition de vecteurs
     */
    vec2Add(v1, v2) {
        return { x: v1.x + v2.x, y: v1.y + v2.y };
    },

    /**
     * Soustraction de vecteurs
     */
    vec2Sub(v1, v2) {
        return { x: v1.x - v2.x, y: v1.y - v2.y };
    },

    /**
     * Multiplication par un scalaire
     */
    vec2Scale(v, scalar) {
        return { x: v.x * scalar, y: v.y * scalar };
    },

    /**
     * Produit scalaire
     */
    vec2Dot(v1, v2) {
        return this.round(v1.x * v2.x + v1.y * v2.y);
    },

    /**
     * Produit vectoriel (composante z)
     */
    vec2Cross(v1, v2) {
        return this.round(v1.x * v2.y - v1.y * v2.x);
    },

    /**
     * Norme d'un vecteur
     */
    vec2Length(v) {
        return this.round(Math.sqrt(v.x * v.x + v.y * v.y));
    },

    /**
     * Normalise un vecteur
     */
    vec2Normalize(v) {
        const len = this.vec2Length(v);
        if (this.isZero(len)) return { x: 0, y: 0 };
        return { x: v.x / len, y: v.y / len };
    },

    /**
     * Distance entre deux points
     */
    distance(p1, p2) {
        return this.vec2Length(this.vec2Sub(p2, p1));
    },

    /**
     * Angle d'un vecteur
     */
    vec2Angle(v) {
        return this.atan2(v.y, v.x);
    },

    /**
     * Rotation d'un vecteur
     */
    vec2Rotate(v, angle) {
        const cos = this.cos(angle);
        const sin = this.sin(angle);
        return {
            x: this.round(v.x * cos - v.y * sin),
            y: this.round(v.x * sin + v.y * cos)
        };
    },

    /**
     * Projection d'un vecteur sur un autre
     */
    vec2Project(v, onto) {
        const dot = this.vec2Dot(v, onto);
        const len2 = this.vec2Dot(onto, onto);
        if (this.isZero(len2)) return { x: 0, y: 0 };
        const scalar = dot / len2;
        return this.vec2Scale(onto, scalar);
    },

    /**
     * Interpolation linéaire entre deux vecteurs
     */
    vec2Lerp(v1, v2, t) {
        return {
            x: this.lerp(v1.x, v2.x, t),
            y: this.lerp(v1.y, v2.y, t)
        };
    },

    // ==========================================
    // GÉOMÉTRIE
    // ==========================================

    /**
     * Point sur un cercle
     */
    pointOnCircle(cx, cy, radius, angle) {
        return {
            x: this.round(cx + radius * this.cos(angle)),
            y: this.round(cy + radius * this.sin(angle))
        };
    },

    /**
     * Point sur une ellipse
     */
    pointOnEllipse(cx, cy, rx, ry, angle) {
        return {
            x: this.round(cx + rx * this.cos(angle)),
            y: this.round(cy + ry * this.sin(angle))
        };
    },

    /**
     * Intersection de deux droites (format paramétrique)
     * Droite 1: P1 + t * D1
     * Droite 2: P2 + s * D2
     */
    lineLineIntersection(p1, d1, p2, d2) {
        const cross = this.vec2Cross(d1, d2);
        if (this.isZero(cross)) return null; // Droites parallèles

        const diff = this.vec2Sub(p2, p1);
        const t = this.vec2Cross(diff, d2) / cross;

        return {
            x: this.round(p1.x + t * d1.x),
            y: this.round(p1.y + t * d1.y),
            t: this.round(t)
        };
    },

    /**
     * Intersection droite-cercle
     */
    lineCircleIntersection(linePoint, lineDir, cx, cy, radius) {
        const d = this.vec2Normalize(lineDir);
        const f = this.vec2Sub(linePoint, { x: cx, y: cy });

        const a = this.vec2Dot(d, d);
        const b = 2 * this.vec2Dot(f, d);
        const c = this.vec2Dot(f, f) - radius * radius;

        const discriminant = b * b - 4 * a * c;

        if (discriminant < 0) return [];

        const sqrtDisc = Math.sqrt(discriminant);
        const t1 = (-b - sqrtDisc) / (2 * a);
        const t2 = (-b + sqrtDisc) / (2 * a);

        const points = [];
        if (!this.equals(t1, t2)) {
            points.push({
                x: this.round(linePoint.x + t1 * d.x),
                y: this.round(linePoint.y + t1 * d.y)
            });
        }
        points.push({
            x: this.round(linePoint.x + t2 * d.x),
            y: this.round(linePoint.y + t2 * d.y)
        });

        return points;
    },

    /**
     * Point le plus proche sur une droite
     */
    closestPointOnLine(point, linePoint, lineDir) {
        const proj = this.vec2Project(
            this.vec2Sub(point, linePoint),
            lineDir
        );
        return this.vec2Add(linePoint, proj);
    },

    /**
     * Distance point-droite
     */
    distancePointToLine(point, linePoint, lineDir) {
        const closest = this.closestPointOnLine(point, linePoint, lineDir);
        return this.distance(point, closest);
    },

    /**
     * Aire d'un triangle (formule de Héron)
     */
    triangleArea(a, b, c) {
        // a, b, c sont les longueurs des côtés
        const s = (a + b + c) / 2;
        return this.round(Math.sqrt(s * (s - a) * (s - b) * (s - c)));
    },

    /**
     * Aire d'un triangle à partir des coordonnées
     */
    triangleAreaFromPoints(p1, p2, p3) {
        return this.round(Math.abs(
            (p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)
        ) / 2);
    },

    // ==========================================
    // COURBES
    // ==========================================

    /**
     * Point sur une courbe de Bézier quadratique
     */
    bezierQuadratic(p0, p1, p2, t) {
        const mt = 1 - t;
        return {
            x: this.round(mt * mt * p0.x + 2 * mt * t * p1.x + t * t * p2.x),
            y: this.round(mt * mt * p0.y + 2 * mt * t * p1.y + t * t * p2.y)
        };
    },

    /**
     * Point sur une courbe de Bézier cubique
     */
    bezierCubic(p0, p1, p2, p3, t) {
        const mt = 1 - t;
        const mt2 = mt * mt;
        const mt3 = mt2 * mt;
        const t2 = t * t;
        const t3 = t2 * t;

        return {
            x: this.round(mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x),
            y: this.round(mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y)
        };
    },

    // ==========================================
    // ALGÈBRE
    // ==========================================

    /**
     * Résout une équation du second degré ax² + bx + c = 0
     */
    solveQuadratic(a, b, c) {
        if (this.isZero(a)) {
            // Équation du premier degré
            if (this.isZero(b)) return [];
            return [this.round(-c / b)];
        }

        const discriminant = b * b - 4 * a * c;

        if (discriminant < 0) return [];
        if (this.isZero(discriminant)) {
            return [this.round(-b / (2 * a))];
        }

        const sqrtDisc = Math.sqrt(discriminant);
        return [
            this.round((-b - sqrtDisc) / (2 * a)),
            this.round((-b + sqrtDisc) / (2 * a))
        ].sort((x, y) => x - y);
    },

    /**
     * PGCD de deux nombres
     */
    gcd(a, b) {
        a = Math.abs(Math.round(a));
        b = Math.abs(Math.round(b));
        while (b !== 0) {
            const temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    },

    /**
     * PPCM de deux nombres
     */
    lcm(a, b) {
        return Math.abs(a * b) / this.gcd(a, b);
    },

    /**
     * Simplifie une fraction
     */
    simplifyFraction(numerator, denominator) {
        const g = this.gcd(numerator, denominator);
        const sign = denominator < 0 ? -1 : 1;
        return {
            numerator: sign * Math.round(numerator / g),
            denominator: Math.abs(Math.round(denominator / g))
        };
    },

    // ==========================================
    // FORMATAGE
    // ==========================================

    /**
     * Formate un nombre pour affichage
     */
    format(value, decimals = 2) {
        if (this.isZero(value)) return '0';
        const rounded = this.round(value, decimals);
        // Supprime les zéros trailing
        return parseFloat(rounded.toFixed(decimals)).toString();
    },

    /**
     * Formate une fraction
     */
    formatFraction(numerator, denominator) {
        const { numerator: n, denominator: d } = this.simplifyFraction(numerator, denominator);
        if (d === 1) return n.toString();
        return `${n}/${d}`;
    },

    /**
     * Formate un angle en notation degré
     */
    formatAngle(radians, decimals = 1) {
        const degrees = this.radToDeg(radians);
        return `${this.format(degrees, decimals)}°`;
    },

    /**
     * Formate des coordonnées
     */
    formatPoint(x, y, decimals = 2) {
        return `(${this.format(x, decimals)} ; ${this.format(y, decimals)})`;
    },

    // ==========================================
    // FONCTIONS D'EASING POUR ANIMATIONS
    // ==========================================

    /**
     * Applique une fonction d'easing à une valeur t (0-1)
     * @param {number} t - Progression (0 à 1)
     * @param {string} type - Type d'easing
     * @returns {number} - Valeur easée (0 à 1)
     */
    ease(t, type = 'linear') {
        t = this.clamp(t, 0, 1);

        const easings = {
            // Linéaire
            linear: t => t,

            // Quadratique
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,

            // Cubique
            easeInCubic: t => t * t * t,
            easeOutCubic: t => (--t) * t * t + 1,
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,

            // Quartique
            easeInQuart: t => t * t * t * t,
            easeOutQuart: t => 1 - (--t) * t * t * t,
            easeInOutQuart: t => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t,

            // Sinusoïdal
            easeInSine: t => 1 - Math.cos(t * Math.PI / 2),
            easeOutSine: t => Math.sin(t * Math.PI / 2),
            easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,

            // Exponentiel
            easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
            easeOutExpo: t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
            easeInOutExpo: t => {
                if (t === 0 || t === 1) return t;
                return t < 0.5
                    ? Math.pow(2, 20 * t - 10) / 2
                    : (2 - Math.pow(2, -20 * t + 10)) / 2;
            },

            // Circulaire
            easeInCirc: t => 1 - Math.sqrt(1 - t * t),
            easeOutCirc: t => Math.sqrt(1 - (--t) * t),
            easeInOutCirc: t => t < 0.5
                ? (1 - Math.sqrt(1 - 4 * t * t)) / 2
                : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,

            // Élastique
            easeInElastic: t => {
                if (t === 0 || t === 1) return t;
                return -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * (2 * Math.PI) / 3);
            },
            easeOutElastic: t => {
                if (t === 0 || t === 1) return t;
                return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI) / 3) + 1;
            },
            easeInOutElastic: t => {
                if (t === 0 || t === 1) return t;
                return t < 0.5
                    ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * (2 * Math.PI) / 4.5)) / 2
                    : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * (2 * Math.PI) / 4.5)) / 2 + 1;
            },

            // Rebond
            easeOutBounce: t => {
                const n1 = 7.5625;
                const d1 = 2.75;
                if (t < 1 / d1) return n1 * t * t;
                if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
                if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
                return n1 * (t -= 2.625 / d1) * t + 0.984375;
            },
            easeInBounce: t => 1 - easings.easeOutBounce(1 - t),
            easeInOutBounce: t => t < 0.5
                ? (1 - easings.easeOutBounce(1 - 2 * t)) / 2
                : (1 + easings.easeOutBounce(2 * t - 1)) / 2,

            // Back (dépassement)
            easeInBack: t => {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return c3 * t * t * t - c1 * t * t;
            },
            easeOutBack: t => {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            },
            easeInOutBack: t => {
                const c1 = 1.70158;
                const c2 = c1 * 1.525;
                return t < 0.5
                    ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2
                    : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
            }
        };

        const fn = easings[type] || easings.linear;
        return this.round(fn(t), 6);
    },

    /**
     * Interpolation avec easing entre deux valeurs
     */
    lerpEase(a, b, t, easing = 'easeInOutQuad') {
        return this.lerp(a, b, this.ease(t, easing));
    }
};

// Export pour utilisation modulaire
if (typeof module !== 'undefined' && module.exports) {
    module.exports = MathUtils;
}


// === canvas-renderer.js ===

/**
 * CANVAS RENDERER
 * Système de rendu optimisé pour les animations mathématiques
 * avec gestion du repère, du zoom et des transformations
 */

class CanvasRenderer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');

        // Configuration du repère mathématique
        this.config = {
            // Origine au centre par défaut
            originX: 0.5,
            originY: 0.5,

            // Échelle (pixels par unité)
            scale: 50,
            minScale: 10,
            maxScale: 200,

            // Grille
            showGrid: true,
            gridColor: '#e5e7eb',
            gridColorMajor: '#d1d5db',
            gridStep: 1,
            gridMajorStep: 5,

            // Axes
            showAxes: true,
            axisColor: '#374151',
            axisWidth: 2,
            axisArrowSize: 10,

            // Labels
            showLabels: true,
            labelColor: '#6b7280',
            labelFont: '14px sans-serif',
            labelFontLarge: '18px sans-serif',

            // Valeurs numériques
            showValues: true,
            valueColor: '#374151',
            valueFont: '12px monospace',

            // Styles de dessin
            defaultStrokeColor: '#2563eb',
            defaultFillColor: 'rgba(37, 99, 235, 0.1)',
            defaultLineWidth: 2,

            // Points
            pointRadius: 5,
            pointColor: '#2563eb',

            // Texte
            fontSize: 16,

            // Animation
            antialias: true
        };

        // État du viewport
        this.viewport = {
            panX: 0,
            panY: 0
        };

        // Initialisation
        this.setupCanvas();
        this.setupResizeObserver();
    }

    // ==========================================
    // INITIALISATION
    // ==========================================

    setupCanvas() {
        this.resize();

        // Activer l'antialiasing
        if (this.config.antialias) {
            this.ctx.imageSmoothingEnabled = true;
            this.ctx.imageSmoothingQuality = 'high';
        }
    }

    setupResizeObserver() {
        const observer = new ResizeObserver(() => {
            this.resize();
        });
        observer.observe(this.canvas.parentElement);
    }

    resize() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        // Taille CSS
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';

        // Taille réelle (haute résolution)
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;

        // Scale pour haute résolution
        this.ctx.scale(dpr, dpr);

        // Stocker les dimensions CSS
        this.width = rect.width;
        this.height = rect.height;

        // Calculer l'origine
        this.originX = this.width * this.config.originX + this.viewport.panX;
        this.originY = this.height * this.config.originY + this.viewport.panY;
    }

    // ==========================================
    // CONVERSION DE COORDONNÉES
    // ==========================================

    /**
     * Convertit coordonnées mathématiques → pixels
     */
    toPixel(x, y) {
        return {
            x: this.originX + x * this.config.scale,
            y: this.originY - y * this.config.scale // Y inversé
        };
    }

    /**
     * Convertit pixels → coordonnées mathématiques
     */
    toMath(px, py) {
        return {
            x: (px - this.originX) / this.config.scale,
            y: (this.originY - py) / this.config.scale
        };
    }

    /**
     * Convertit une longueur math → pixels
     */
    toPixelLength(length) {
        return length * this.config.scale;
    }

    /**
     * Convertit une longueur pixels → math
     */
    toMathLength(pixels) {
        return pixels / this.config.scale;
    }

    // ==========================================
    // VIEWPORT
    // ==========================================

    setScale(scale) {
        this.config.scale = MathUtils.clamp(scale, this.config.minScale, this.config.maxScale);
        this.resize();
    }

    zoom(factor, centerX = this.width / 2, centerY = this.height / 2) {
        const oldScale = this.config.scale;
        const newScale = MathUtils.clamp(
            oldScale * factor,
            this.config.minScale,
            this.config.maxScale
        );

        // Zoom vers le point centre
        const mathPoint = this.toMath(centerX, centerY);
        this.config.scale = newScale;
        const newPixel = this.toPixel(mathPoint.x, mathPoint.y);

        this.viewport.panX += centerX - newPixel.x;
        this.viewport.panY += centerY - newPixel.y;

        this.resize();
    }

    pan(dx, dy) {
        this.viewport.panX += dx;
        this.viewport.panY += dy;
        this.resize();
    }

    resetViewport() {
        this.viewport.panX = 0;
        this.viewport.panY = 0;
        this.config.scale = 50;
        this.resize();
    }

    // ==========================================
    // DESSIN DE BASE
    // ==========================================

    clear(color = '#ffffff') {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(0, 0, this.width, this.height);
    }

    // ==========================================
    // GRILLE ET AXES
    // ==========================================

    drawGrid() {
        if (!this.config.showGrid) return;

        const bounds = this.getViewBounds();
        const step = this.config.gridStep;
        const majorStep = this.config.gridMajorStep;

        // Lignes verticales
        const startX = Math.floor(bounds.minX / step) * step;
        for (let x = startX; x <= bounds.maxX; x += step) {
            const px = this.toPixel(x, 0).x;
            const isMajor = MathUtils.isZero(x % majorStep);

            this.ctx.beginPath();
            this.ctx.strokeStyle = isMajor ? this.config.gridColorMajor : this.config.gridColor;
            this.ctx.lineWidth = isMajor ? 1 : 0.5;
            this.ctx.moveTo(px, 0);
            this.ctx.lineTo(px, this.height);
            this.ctx.stroke();
        }

        // Lignes horizontales
        const startY = Math.floor(bounds.minY / step) * step;
        for (let y = startY; y <= bounds.maxY; y += step) {
            const py = this.toPixel(0, y).y;
            const isMajor = MathUtils.isZero(y % majorStep);

            this.ctx.beginPath();
            this.ctx.strokeStyle = isMajor ? this.config.gridColorMajor : this.config.gridColor;
            this.ctx.lineWidth = isMajor ? 1 : 0.5;
            this.ctx.moveTo(0, py);
            this.ctx.lineTo(this.width, py);
            this.ctx.stroke();
        }
    }

    drawAxes() {
        if (!this.config.showAxes) return;

        const ctx = this.ctx;
        const origin = this.toPixel(0, 0);

        ctx.strokeStyle = this.config.axisColor;
        ctx.lineWidth = this.config.axisWidth;
        ctx.lineCap = 'round';

        // Axe X
        ctx.beginPath();
        ctx.moveTo(0, origin.y);
        ctx.lineTo(this.width, origin.y);
        ctx.stroke();

        // Flèche X
        this.drawArrow(this.width - 10, origin.y, 0);

        // Axe Y
        ctx.beginPath();
        ctx.moveTo(origin.x, this.height);
        ctx.lineTo(origin.x, 0);
        ctx.stroke();

        // Flèche Y
        this.drawArrow(origin.x, 10, -Math.PI / 2);

        // Labels des axes
        if (this.config.showLabels) {
            ctx.fillStyle = this.config.labelColor;
            ctx.font = this.config.labelFontLarge;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText('x', this.width - 25, origin.y + 8);

            ctx.textAlign = 'left';
            ctx.textBaseline = 'bottom';
            ctx.fillText('y', origin.x + 10, 25);
        }

        // Graduations et valeurs
        if (this.config.showValues) {
            this.drawAxisValues();
        }
    }

    drawArrow(x, y, angle) {
        const ctx = this.ctx;
        const size = this.config.axisArrowSize;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-size, -size / 2);
        ctx.lineTo(-size, size / 2);
        ctx.closePath();
        ctx.fillStyle = this.config.axisColor;
        ctx.fill();

        ctx.restore();
    }

    drawAxisValues() {
        const ctx = this.ctx;
        const bounds = this.getViewBounds();
        const step = this.config.gridMajorStep;

        ctx.fillStyle = this.config.valueColor;
        ctx.font = this.config.valueFont;

        // Valeurs sur X
        const startX = Math.ceil(bounds.minX / step) * step;
        for (let x = startX; x <= bounds.maxX; x += step) {
            if (MathUtils.isZero(x)) continue;
            const px = this.toPixel(x, 0);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(MathUtils.format(x, 0), px.x, px.y + 8);
        }

        // Valeurs sur Y
        const startY = Math.ceil(bounds.minY / step) * step;
        for (let y = startY; y <= bounds.maxY; y += step) {
            if (MathUtils.isZero(y)) continue;
            const py = this.toPixel(0, y);
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(MathUtils.format(y, 0), py.x - 8, py.y);
        }

        // Origine
        const origin = this.toPixel(0, 0);
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.fillText('O', origin.x - 8, origin.y + 8);
    }

    getViewBounds() {
        const topLeft = this.toMath(0, 0);
        const bottomRight = this.toMath(this.width, this.height);

        return {
            minX: topLeft.x,
            maxX: bottomRight.x,
            minY: bottomRight.y,
            maxY: topLeft.y
        };
    }

    // ==========================================
    // PRIMITIVES DE DESSIN
    // ==========================================

    /**
     * Dessine un point
     */
    drawPoint(x, y, options = {}) {
        const {
            radius = this.config.pointRadius,
            color = this.config.pointColor,
            label = null,
            labelOffset = { x: 10, y: -10 }
        } = options;

        const p = this.toPixel(x, y);

        // Point
        this.ctx.beginPath();
        this.ctx.arc(p.x, p.y, radius, 0, MathUtils.TAU);
        this.ctx.fillStyle = color;
        this.ctx.fill();

        // Label
        if (label && this.config.showLabels) {
            this.ctx.fillStyle = color;
            this.ctx.font = this.config.labelFont;
            this.ctx.textAlign = 'left';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(label, p.x + labelOffset.x, p.y + labelOffset.y);
        }
    }

    /**
     * Dessine un segment
     */
    drawSegment(x1, y1, x2, y2, options = {}) {
        const {
            color = this.config.defaultStrokeColor,
            width = this.config.defaultLineWidth,
            dashed = false,
            dashPattern = [5, 5]
        } = options;

        const p1 = this.toPixel(x1, y1);
        const p2 = this.toPixel(x2, y2);

        this.ctx.beginPath();
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = width;
        this.ctx.setLineDash(dashed ? dashPattern : []);
        this.ctx.moveTo(p1.x, p1.y);
        this.ctx.lineTo(p2.x, p2.y);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
    }

    /**
     * Dessine une droite (infinie)
     */
    drawLine(x1, y1, x2, y2, options = {}) {
        const bounds = this.getViewBounds();
        const dx = x2 - x1;
        const dy = y2 - y1;

        // Trouver les intersections avec les bords du viewport
        let tMin = -Infinity;
        let tMax = Infinity;

        if (!MathUtils.isZero(dx)) {
            const t1 = (bounds.minX - x1) / dx;
            const t2 = (bounds.maxX - x1) / dx;
            tMin = Math.max(tMin, Math.min(t1, t2));
            tMax = Math.min(tMax, Math.max(t1, t2));
        }

        if (!MathUtils.isZero(dy)) {
            const t1 = (bounds.minY - y1) / dy;
            const t2 = (bounds.maxY - y1) / dy;
            tMin = Math.max(tMin, Math.min(t1, t2));
            tMax = Math.min(tMax, Math.max(t1, t2));
        }

        if (tMin < tMax) {
            const startX = x1 + tMin * dx;
            const startY = y1 + tMin * dy;
            const endX = x1 + tMax * dx;
            const endY = y1 + tMax * dy;

            this.drawSegment(startX, startY, endX, endY, options);
        }
    }

    /**
     * Dessine un vecteur avec flèche
     */
    drawVector(x1, y1, x2, y2, options = {}) {
        const {
            color = this.config.defaultStrokeColor,
            width = this.config.defaultLineWidth,
            arrowSize = 12
        } = options;

        const p1 = this.toPixel(x1, y1);
        const p2 = this.toPixel(x2, y2);

        // Ligne
        this.ctx.beginPath();
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = width;
        this.ctx.moveTo(p1.x, p1.y);
        this.ctx.lineTo(p2.x, p2.y);
        this.ctx.stroke();

        // Flèche
        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

        this.ctx.save();
        this.ctx.translate(p2.x, p2.y);
        this.ctx.rotate(angle);

        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo(-arrowSize, -arrowSize / 2);
        this.ctx.lineTo(-arrowSize, arrowSize / 2);
        this.ctx.closePath();
        this.ctx.fillStyle = color;
        this.ctx.fill();

        this.ctx.restore();
    }

    /**
     * Dessine un cercle
     */
    drawCircle(cx, cy, radius, options = {}) {
        const {
            strokeColor = this.config.defaultStrokeColor,
            fillColor = null,
            lineWidth = this.config.defaultLineWidth,
            dashed = false
        } = options;

        const center = this.toPixel(cx, cy);
        const r = this.toPixelLength(radius);

        this.ctx.beginPath();
        this.ctx.arc(center.x, center.y, r, 0, MathUtils.TAU);

        if (fillColor) {
            this.ctx.fillStyle = fillColor;
            this.ctx.fill();
        }

        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = lineWidth;
        this.ctx.setLineDash(dashed ? [5, 5] : []);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
    }

    /**
     * Dessine un arc de cercle
     */
    drawArc(cx, cy, radius, startAngle, endAngle, options = {}) {
        const {
            strokeColor = this.config.defaultStrokeColor,
            fillColor = null,
            lineWidth = this.config.defaultLineWidth,
            counterClockwise = false
        } = options;

        const center = this.toPixel(cx, cy);
        const r = this.toPixelLength(radius);

        // Convertir les angles (y inversé)
        const start = -startAngle;
        const end = -endAngle;

        this.ctx.beginPath();
        this.ctx.arc(center.x, center.y, r, start, end, !counterClockwise);

        if (fillColor) {
            this.ctx.lineTo(center.x, center.y);
            this.ctx.closePath();
            this.ctx.fillStyle = fillColor;
            this.ctx.fill();
        }

        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = lineWidth;
        this.ctx.stroke();
    }

    /**
     * Dessine un angle (arc avec éventuellement la valeur)
     */
    drawAngle(cx, cy, startAngle, endAngle, options = {}) {
        const {
            radius = 0.5,
            strokeColor = this.config.defaultStrokeColor,
            fillColor = 'rgba(37, 99, 235, 0.1)',
            showValue = true,
            valueOffset = 1.5
        } = options;

        // Dessiner l'arc
        this.drawArc(cx, cy, radius, startAngle, endAngle, { strokeColor, fillColor });

        // Afficher la valeur
        if (showValue && this.config.showValues) {
            const midAngle = (startAngle + endAngle) / 2;
            const labelPos = MathUtils.pointOnCircle(cx, cy, radius * valueOffset, midAngle);
            const angleDeg = MathUtils.radToDeg(Math.abs(endAngle - startAngle));

            this.drawText(
                MathUtils.format(angleDeg, 0) + '°',
                labelPos.x, labelPos.y,
                { color: strokeColor, align: 'center' }
            );
        }
    }

    /**
     * Dessine un polygone
     */
    drawPolygon(points, options = {}) {
        const {
            strokeColor = this.config.defaultStrokeColor,
            fillColor = null,
            lineWidth = this.config.defaultLineWidth,
            closed = true
        } = options;

        if (points.length < 2) return;

        this.ctx.beginPath();
        const start = this.toPixel(points[0].x, points[0].y);
        this.ctx.moveTo(start.x, start.y);

        for (let i = 1; i < points.length; i++) {
            const p = this.toPixel(points[i].x, points[i].y);
            this.ctx.lineTo(p.x, p.y);
        }

        if (closed) {
            this.ctx.closePath();
        }

        if (fillColor) {
            this.ctx.fillStyle = fillColor;
            this.ctx.fill();
        }

        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = lineWidth;
        this.ctx.stroke();
    }

    /**
     * Dessine une fonction y = f(x)
     */
    drawFunction(fn, options = {}) {
        const {
            color = this.config.defaultStrokeColor,
            lineWidth = this.config.defaultLineWidth,
            minX = null,
            maxX = null,
            step = null
        } = options;

        const bounds = this.getViewBounds();
        const xMin = minX !== null ? minX : bounds.minX;
        const xMax = maxX !== null ? maxX : bounds.maxX;
        const pixelStep = step || 2;
        const mathStep = this.toMathLength(pixelStep);

        this.ctx.beginPath();
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = lineWidth;

        let started = false;

        for (let x = xMin; x <= xMax; x += mathStep) {
            try {
                const y = fn(x);

                if (!isFinite(y) || isNaN(y)) {
                    started = false;
                    continue;
                }

                const p = this.toPixel(x, y);

                if (!started) {
                    this.ctx.moveTo(p.x, p.y);
                    started = true;
                } else {
                    this.ctx.lineTo(p.x, p.y);
                }
            } catch {
                started = false;
            }
        }

        this.ctx.stroke();
    }

    /**
     * Dessine du texte
     */
    drawText(text, x, y, options = {}) {
        const {
            color = this.config.labelColor,
            font = this.config.labelFont,
            align = 'left',
            baseline = 'middle',
            inMathCoords = true
        } = options;

        const pos = inMathCoords ? this.toPixel(x, y) : { x, y };

        this.ctx.fillStyle = color;
        this.ctx.font = font;
        this.ctx.textAlign = align;
        this.ctx.textBaseline = baseline;
        this.ctx.fillText(text, pos.x, pos.y);
    }

    /**
     * Dessine une image à une position donnée
     */
    drawImage(img, x, y, width, height, options = {}) {
        const {
            inMathCoords = true,
            centered = false
        } = options;

        let pos = inMathCoords ? this.toPixel(x, y) : { x, y };
        const w = inMathCoords ? this.toPixelLength(width) : width;
        const h = inMathCoords ? this.toPixelLength(height) : height;

        if (centered) {
            pos.x -= w / 2;
            pos.y -= h / 2;
        }

        this.ctx.drawImage(img, pos.x, pos.y, w, h);
    }

    // ==========================================
    // UTILITAIRES DE STYLE
    // ==========================================

    setStyle(options) {
        Object.assign(this.config, options);
    }

    getStyle() {
        return { ...this.config };
    }
}

// Export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CanvasRenderer;
}


// === animation-core.js ===

/**
 * ANIMATION CORE
 * Gestion de la boucle d'animation, des états et des transitions
 */

class AnimationCore {
    constructor(renderer) {
        this.renderer = renderer;

        // État de l'animation
        this.isRunning = false;
        this.isPaused = false;
        this.animationId = null;

        // Timing
        this.lastTime = 0;
        this.deltaTime = 0;
        this.elapsedTime = 0;
        this.fps = 60;
        this.frameInterval = 1000 / this.fps;

        // Callbacks
        this.onUpdate = null;
        this.onRender = null;

        // Animations programmées
        this.animations = new Map();
        this.animationIdCounter = 0;

        // Transitions
        this.transitions = new Map();

        // Fonctions d'easing
        this.easingFunctions = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            easeInCubic: t => t * t * t,
            easeOutCubic: t => (--t) * t * t + 1,
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
            easeInQuart: t => t * t * t * t,
            easeOutQuart: t => 1 - (--t) * t * t * t,
            easeInOutQuart: t => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t,
            easeInSine: t => 1 - Math.cos(t * Math.PI / 2),
            easeOutSine: t => Math.sin(t * Math.PI / 2),
            easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,
            easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
            easeOutExpo: t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
            easeInOutExpo: t => {
                if (t === 0) return 0;
                if (t === 1) return 1;
                if (t < 0.5) return Math.pow(2, 20 * t - 10) / 2;
                return (2 - Math.pow(2, -20 * t + 10)) / 2;
            },
            easeInElastic: t => {
                if (t === 0) return 0;
                if (t === 1) return 1;
                return -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * (2 * Math.PI) / 3);
            },
            easeOutElastic: t => {
                if (t === 0) return 0;
                if (t === 1) return 1;
                return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI) / 3) + 1;
            },
            easeOutBounce: t => {
                const n1 = 7.5625;
                const d1 = 2.75;
                if (t < 1 / d1) return n1 * t * t;
                if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
                if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
                return n1 * (t -= 2.625 / d1) * t + 0.984375;
            }
        };
    }

    // ==========================================
    // CONTRÔLE DE LA BOUCLE
    // ==========================================

    start() {
        if (this.isRunning) return;

        this.isRunning = true;
        this.isPaused = false;
        this.lastTime = performance.now();

        this.loop();
    }

    stop() {
        this.isRunning = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }

    pause() {
        this.isPaused = true;
    }

    resume() {
        if (!this.isRunning) {
            this.start();
        } else {
            this.isPaused = false;
            this.lastTime = performance.now();
        }
    }

    toggle() {
        if (this.isPaused) {
            this.resume();
        } else {
            this.pause();
        }
    }

    reset() {
        this.elapsedTime = 0;
        this.animations.clear();
        this.transitions.clear();
    }

    loop() {
        if (!this.isRunning) return;

        this.animationId = requestAnimationFrame(() => this.loop());

        const currentTime = performance.now();
        this.deltaTime = currentTime - this.lastTime;

        // Limiter le frame rate si nécessaire
        if (this.deltaTime < this.frameInterval) return;

        this.lastTime = currentTime - (this.deltaTime % this.frameInterval);

        if (!this.isPaused) {
            this.elapsedTime += this.deltaTime;

            // Mise à jour des animations
            this.updateAnimations();

            // Mise à jour des transitions
            this.updateTransitions();

            // Callback de mise à jour personnalisé
            if (this.onUpdate) {
                this.onUpdate(this.deltaTime, this.elapsedTime);
            }
        }

        // Rendu
        this.render();
    }

    render() {
        // Clear et dessiner la grille/axes
        this.renderer.clear();
        this.renderer.drawGrid();
        this.renderer.drawAxes();

        // Callback de rendu personnalisé
        if (this.onRender) {
            this.onRender(this.renderer);
        }
    }

    // ==========================================
    // ANIMATIONS PROGRAMMÉES
    // ==========================================

    /**
     * Crée une animation
     * @param {Object} options Configuration de l'animation
     * @returns {number} ID de l'animation
     */
    animate(options) {
        const {
            from,
            to,
            duration = 1000,
            easing = 'easeInOutQuad',
            delay = 0,
            loop = false,
            yoyo = false,
            onUpdate,
            onComplete
        } = options;

        const id = ++this.animationIdCounter;

        const animation = {
            id,
            from,
            to,
            duration,
            easing: typeof easing === 'function' ? easing : this.easingFunctions[easing],
            delay,
            loop,
            yoyo,
            onUpdate,
            onComplete,
            startTime: this.elapsedTime + delay,
            direction: 1,
            completed: false
        };

        this.animations.set(id, animation);

        return id;
    }

    /**
     * Annule une animation
     */
    cancelAnimation(id) {
        this.animations.delete(id);
    }

    /**
     * Met à jour toutes les animations actives
     */
    updateAnimations() {
        for (const [id, anim] of this.animations) {
            if (anim.completed) continue;

            const elapsed = this.elapsedTime - anim.startTime;

            if (elapsed < 0) continue; // Pas encore démarré (delay)

            let progress = Math.min(elapsed / anim.duration, 1);

            // Appliquer le yoyo
            if (anim.yoyo && anim.direction === -1) {
                progress = 1 - progress;
            }

            // Appliquer l'easing
            const easedProgress = anim.easing(progress);

            // Calculer la valeur interpolée
            const value = this.interpolateValue(anim.from, anim.to, easedProgress);

            // Callback de mise à jour
            if (anim.onUpdate) {
                anim.onUpdate(value, progress);
            }

            // Vérifier si terminé
            if (elapsed >= anim.duration) {
                if (anim.loop) {
                    if (anim.yoyo) {
                        anim.direction *= -1;
                    }
                    anim.startTime = this.elapsedTime;
                } else {
                    anim.completed = true;
                    if (anim.onComplete) {
                        anim.onComplete();
                    }
                    this.animations.delete(id);
                }
            }
        }
    }

    /**
     * Interpole une valeur (supporte nombres, objets, tableaux)
     */
    interpolateValue(from, to, t) {
        // Nombre
        if (typeof from === 'number' && typeof to === 'number') {
            return MathUtils.lerp(from, to, t);
        }

        // Tableau
        if (Array.isArray(from) && Array.isArray(to)) {
            return from.map((v, i) => this.interpolateValue(v, to[i], t));
        }

        // Objet
        if (typeof from === 'object' && typeof to === 'object') {
            const result = {};
            for (const key of Object.keys(from)) {
                if (to.hasOwnProperty(key)) {
                    result[key] = this.interpolateValue(from[key], to[key], t);
                }
            }
            return result;
        }

        return from;
    }

    // ==========================================
    // TRANSITIONS SIMPLES
    // ==========================================

    /**
     * Crée une transition simple sur une propriété
     */
    transition(target, property, toValue, duration = 500, easing = 'easeOutQuad') {
        const key = `${target.constructor.name}_${property}`;

        // Annuler transition existante
        if (this.transitions.has(key)) {
            this.transitions.delete(key);
        }

        const fromValue = target[property];

        this.animate({
            from: fromValue,
            to: toValue,
            duration,
            easing,
            onUpdate: (value) => {
                target[property] = value;
            },
            onComplete: () => {
                this.transitions.delete(key);
            }
        });

        this.transitions.set(key, true);
    }

    /**
     * Met à jour les transitions
     */
    updateTransitions() {
        // Géré par updateAnimations
    }

    // ==========================================
    // SÉQUENCES D'ANIMATION
    // ==========================================

    /**
     * Crée une séquence d'animations
     * @param {Array} steps Tableau d'objets d'animation
     * @returns {Promise} Promesse résolue à la fin de la séquence
     */
    sequence(steps) {
        return new Promise(async (resolve) => {
            for (const step of steps) {
                await this.animateAsync(step);
            }
            resolve();
        });
    }

    /**
     * Version async de animate
     */
    animateAsync(options) {
        return new Promise((resolve) => {
            const originalOnComplete = options.onComplete;
            options.onComplete = () => {
                if (originalOnComplete) originalOnComplete();
                resolve();
            };
            this.animate(options);
        });
    }

    /**
     * Attend un délai
     */
    wait(duration) {
        return new Promise(resolve => {
            setTimeout(resolve, duration);
        });
    }

    /**
     * Exécute des animations en parallèle
     */
    parallel(animations) {
        return Promise.all(animations.map(anim => this.animateAsync(anim)));
    }

    // ==========================================
    // UTILITAIRES
    // ==========================================

    setFPS(fps) {
        this.fps = fps;
        this.frameInterval = 1000 / fps;
    }

    getElapsedTime() {
        return this.elapsedTime;
    }

    getElapsedSeconds() {
        return this.elapsedTime / 1000;
    }

    /**
     * Obtient une fonction d'easing par nom
     */
    getEasing(name) {
        return this.easingFunctions[name] || this.easingFunctions.linear;
    }

    /**
     * Ajoute une fonction d'easing personnalisée
     */
    addEasing(name, fn) {
        this.easingFunctions[name] = fn;
    }
}

// Export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = AnimationCore;
}


// === timeline.js ===

/**
 * Timeline - Système de lecture d'animations séquentielles
 * Gère la lecture, pause, navigation et synchronisation des scènes
 */

const Timeline = {
    // État de la timeline
    state: {
        isPlaying: false,
        currentTime: 0,      // Temps actuel en ms
        totalDuration: 0,    // Durée totale en ms
        speed: 1,            // Multiplicateur de vitesse
        currentSceneIndex: 0,
        scenes: [],          // Liste des scènes
        lastFrameTime: 0
    },

    // Références DOM
    dom: {
        playBtn: null,
        progressBar: null,
        progressFill: null,
        progressHandle: null,
        timeCurrent: null,
        timeTotal: null,
        scenesBar: null,
        speedBtns: null
    },

    // Callbacks
    callbacks: {
        onTimeUpdate: null,
        onSceneChange: null,
        onPlay: null,
        onPause: null,
        onSeek: null
    },

    /**
     * Initialisation de la timeline
     */
    init(scenes, callbacks = {}) {
        this.state.scenes = scenes || [];
        this.callbacks = { ...this.callbacks, ...callbacks };

        // Calculer la durée totale
        this.state.totalDuration = this.state.scenes.reduce((total, scene) => total + scene.duration, 0);

        // Récupérer les éléments DOM
        this.dom.playBtn = document.getElementById('tl-play');
        this.dom.progressBar = document.getElementById('progress-bar');
        this.dom.progressFill = document.getElementById('progress-fill');
        this.dom.progressHandle = document.getElementById('progress-handle');
        this.dom.timeCurrent = document.getElementById('time-current');
        this.dom.timeTotal = document.getElementById('time-total');
        this.dom.scenesBar = document.getElementById('scenes-bar');
        this.dom.speedBtns = document.querySelectorAll('.speed-btn');

        // Initialiser l'affichage
        this.updateTimeDisplay();
        this.renderSceneButtons();
        this.addSceneMarkers();
        this.bindEvents();

        return this;
    },

    /**
     * Bindre les événements
     */
    bindEvents() {
        // Bouton play/pause
        this.dom.playBtn?.addEventListener('click', () => this.togglePlay());

        // Navigation
        document.getElementById('tl-prev-scene')?.addEventListener('click', () => this.prevScene());
        document.getElementById('tl-next-scene')?.addEventListener('click', () => this.nextScene());
        document.getElementById('tl-step-back')?.addEventListener('click', () => this.stepBack());
        document.getElementById('tl-step-forward')?.addEventListener('click', () => this.stepForward());

        // Barre de progression
        this.dom.progressBar?.addEventListener('click', (e) => this.seekToPosition(e));
        this.dom.progressBar?.addEventListener('mousedown', (e) => this.startDrag(e));

        // Vitesse
        this.dom.speedBtns?.forEach(btn => {
            btn.addEventListener('click', () => this.setSpeed(parseFloat(btn.dataset.speed)));
        });

        // Raccourcis clavier
        document.addEventListener('keydown', (e) => this.handleKeyboard(e));
    },

    /**
     * Basculer lecture/pause
     */
    togglePlay() {
        if (this.state.isPlaying) {
            this.pause();
        } else {
            this.play();
        }
    },

    /**
     * Démarrer la lecture
     */
    play() {
        if (this.state.currentTime >= this.state.totalDuration) {
            this.seek(0);
        }

        this.state.isPlaying = true;
        this.state.lastFrameTime = performance.now();
        this.dom.playBtn?.classList.add('playing');
        this.dom.playBtn.textContent = '⏸';

        this.callbacks.onPlay?.();
        this.tick();
    },

    /**
     * Mettre en pause
     */
    pause() {
        this.state.isPlaying = false;
        this.dom.playBtn?.classList.remove('playing');
        this.dom.playBtn.textContent = '▶';

        this.callbacks.onPause?.();
    },

    /**
     * Boucle d'animation
     */
    tick() {
        if (!this.state.isPlaying) return;

        const now = performance.now();
        const delta = (now - this.state.lastFrameTime) * this.state.speed;
        this.state.lastFrameTime = now;

        this.state.currentTime = Math.min(
            this.state.currentTime + delta,
            this.state.totalDuration
        );

        this.updateProgress();
        this.updateTimeDisplay();
        this.checkSceneChange();

        this.callbacks.onTimeUpdate?.(this.state.currentTime, this.getCurrentScene());

        // Fin de l'animation
        if (this.state.currentTime >= this.state.totalDuration) {
            this.pause();
            return;
        }

        requestAnimationFrame(() => this.tick());
    },

    /**
     * Naviguer à un temps précis
     */
    seek(timeMs) {
        this.state.currentTime = MathUtils.clamp(timeMs, 0, this.state.totalDuration);
        this.updateProgress();
        this.updateTimeDisplay();
        this.checkSceneChange();

        this.callbacks.onSeek?.(this.state.currentTime);
        this.callbacks.onTimeUpdate?.(this.state.currentTime, this.getCurrentScene());
    },

    /**
     * Naviguer via clic sur la barre
     */
    seekToPosition(e) {
        const rect = this.dom.progressBar.getBoundingClientRect();
        const ratio = (e.clientX - rect.left) / rect.width;
        this.seek(ratio * this.state.totalDuration);
    },

    /**
     * Glisser-déposer sur la timeline
     */
    startDrag(e) {
        e.preventDefault();
        const wasPlaying = this.state.isPlaying;
        if (wasPlaying) this.pause();

        const onMove = (e) => {
            const rect = this.dom.progressBar.getBoundingClientRect();
            const ratio = MathUtils.clamp((e.clientX - rect.left) / rect.width, 0, 1);
            this.seek(ratio * this.state.totalDuration);
        };

        const onUp = () => {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            if (wasPlaying) this.play();
        };

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
    },

    /**
     * Scène précédente
     */
    prevScene() {
        const sceneStart = this.getSceneStartTime(this.state.currentSceneIndex);

        // Si on est au début de la scène, aller à la précédente
        if (this.state.currentTime - sceneStart < 500 && this.state.currentSceneIndex > 0) {
            this.goToScene(this.state.currentSceneIndex - 1);
        } else {
            // Sinon, revenir au début de la scène actuelle
            this.seek(sceneStart);
        }
    },

    /**
     * Scène suivante
     */
    nextScene() {
        if (this.state.currentSceneIndex < this.state.scenes.length - 1) {
            this.goToScene(this.state.currentSceneIndex + 1);
        }
    },

    /**
     * Reculer (grand pas = 2s, petit pas = 200ms frame par frame)
     */
    stepBack(frameByFrame = false) {
        const step = frameByFrame ? 200 : 2000;
        this.seek(this.state.currentTime - step);
    },

    /**
     * Avancer (grand pas = 2s, petit pas = 200ms frame par frame)
     */
    stepForward(frameByFrame = false) {
        const step = frameByFrame ? 200 : 2000;
        this.seek(this.state.currentTime + step);
    },

    /**
     * Navigation frame par frame (petit pas de 200ms)
     */
    frameBack() {
        this.seek(this.state.currentTime - 200);
    },

    frameForward() {
        this.seek(this.state.currentTime + 200);
    },

    /**
     * Aller à une scène spécifique
     */
    goToScene(index) {
        if (index >= 0 && index < this.state.scenes.length) {
            const time = this.getSceneStartTime(index);
            this.seek(time);
        }
    },

    /**
     * Définir la vitesse
     */
    setSpeed(speed) {
        this.state.speed = speed;

        this.dom.speedBtns?.forEach(btn => {
            btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
        });
    },

    /**
     * Obtenir le temps de début d'une scène
     */
    getSceneStartTime(index) {
        let time = 0;
        for (let i = 0; i < index && i < this.state.scenes.length; i++) {
            time += this.state.scenes[i].duration;
        }
        return time;
    },

    /**
     * Obtenir la scène actuelle
     */
    getCurrentScene() {
        let time = 0;
        for (let i = 0; i < this.state.scenes.length; i++) {
            if (this.state.currentTime < time + this.state.scenes[i].duration) {
                return {
                    scene: this.state.scenes[i],
                    index: i,
                    localTime: this.state.currentTime - time,
                    progress: (this.state.currentTime - time) / this.state.scenes[i].duration
                };
            }
            time += this.state.scenes[i].duration;
        }
        // Retourner la dernière scène si on est à la fin
        const lastIndex = this.state.scenes.length - 1;
        return {
            scene: this.state.scenes[lastIndex],
            index: lastIndex,
            localTime: this.state.scenes[lastIndex]?.duration || 0,
            progress: 1
        };
    },

    /**
     * Vérifier si on a changé de scène
     */
    checkSceneChange() {
        const current = this.getCurrentScene();
        if (current.index !== this.state.currentSceneIndex) {
            this.state.currentSceneIndex = current.index;
            this.updateSceneButtons();
            this.callbacks.onSceneChange?.(current);
        }
    },

    /**
     * Mettre à jour la barre de progression
     */
    updateProgress() {
        const ratio = this.state.currentTime / this.state.totalDuration;
        const percent = (ratio * 100).toFixed(2) + '%';

        if (this.dom.progressFill) {
            this.dom.progressFill.style.width = percent;
        }
        if (this.dom.progressHandle) {
            this.dom.progressHandle.style.left = percent;
        }
    },

    /**
     * Mettre à jour l'affichage du temps
     */
    updateTimeDisplay() {
        if (this.dom.timeCurrent) {
            this.dom.timeCurrent.textContent = this.formatTime(this.state.currentTime);
        }
        if (this.dom.timeTotal) {
            this.dom.timeTotal.textContent = this.formatTime(this.state.totalDuration);
        }
    },

    /**
     * Formater le temps en mm:ss
     */
    formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    },

    /**
     * Rendre les boutons de scènes
     */
    renderSceneButtons() {
        if (!this.dom.scenesBar) return;

        this.dom.scenesBar.innerHTML = '';

        this.state.scenes.forEach((scene, index) => {
            const btn = document.createElement('button');
            btn.className = 'scene-btn' + (index === 0 ? ' active' : '');
            btn.textContent = scene.title;
            btn.addEventListener('click', () => this.goToScene(index));
            this.dom.scenesBar.appendChild(btn);
        });
    },

    /**
     * Mettre à jour les boutons de scènes
     */
    updateSceneButtons() {
        const buttons = this.dom.scenesBar?.querySelectorAll('.scene-btn');
        buttons?.forEach((btn, index) => {
            btn.classList.toggle('active', index === this.state.currentSceneIndex);
            btn.classList.toggle('completed', index < this.state.currentSceneIndex);
        });
    },

    /**
     * Ajouter les marqueurs de scènes sur la timeline
     */
    addSceneMarkers() {
        if (!this.dom.progressBar || this.state.scenes.length < 2) return;

        // Supprimer les anciens marqueurs
        this.dom.progressBar.querySelectorAll('.scene-marker').forEach(m => m.remove());

        let time = 0;
        for (let i = 0; i < this.state.scenes.length - 1; i++) {
            time += this.state.scenes[i].duration;
            const ratio = time / this.state.totalDuration;

            const marker = document.createElement('div');
            marker.className = 'scene-marker';
            marker.style.left = (ratio * 100) + '%';
            marker.title = this.state.scenes[i + 1].title;

            this.dom.progressBar.appendChild(marker);
        }
    },

    /**
     * Gestion des raccourcis clavier
     * - Fleches : navigation frame par frame (200ms)
     * - Shift+Fleches : scene precedente/suivante
     * - Ctrl+Fleches : pas de 2 secondes
     */
    handleKeyboard(e) {
        // Ne pas interférer avec les inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        switch (e.code) {
            case 'Space':
                e.preventDefault();
                this.togglePlay();
                break;
            case 'ArrowLeft':
                e.preventDefault();
                if (e.shiftKey) {
                    this.prevScene();
                } else if (e.ctrlKey) {
                    this.stepBack(false); // 2 secondes
                } else {
                    this.frameBack(); // Frame par frame (200ms)
                }
                break;
            case 'ArrowRight':
                e.preventDefault();
                if (e.shiftKey) {
                    this.nextScene();
                } else if (e.ctrlKey) {
                    this.stepForward(false); // 2 secondes
                } else {
                    this.frameForward(); // Frame par frame (200ms)
                }
                break;
            case 'Home':
                e.preventDefault();
                this.seek(0);
                break;
            case 'End':
                e.preventDefault();
                this.seek(this.state.totalDuration);
                break;
            case 'Digit1':
            case 'Digit2':
            case 'Digit3':
            case 'Digit4':
            case 'Digit5':
            case 'Digit6':
            case 'Digit7':
            case 'Digit8':
            case 'Digit9':
                const sceneIndex = parseInt(e.code.replace('Digit', '')) - 1;
                if (sceneIndex < this.state.scenes.length) {
                    e.preventDefault();
                    this.goToScene(sceneIndex);
                }
                break;
        }
    },

    /**
     * Réinitialiser la timeline
     */
    reset() {
        this.pause();
        this.seek(0);
    },

    /**
     * Obtenir l'état actuel
     */
    getState() {
        return {
            ...this.state,
            currentScene: this.getCurrentScene()
        };
    }
};


// === controls.js ===

/**
 * CONTROLS
 * Gestion des contrôles UI et des interactions utilisateur
 */

class Controls {
    constructor() {
        // Éléments DOM
        this.controlPanel = document.getElementById('control-panel');
        this.panelToggle = document.getElementById('panel-toggle');

        // État des paramètres
        this.params = {};

        // Callbacks
        this.onChange = null;
        this.onReset = null;

        // Initialisation
        this.init();
    }

    // ==========================================
    // INITIALISATION
    // ==========================================

    init() {
        this.setupPanelToggle();
        this.setupSectionCollapse();
        this.setupMenuTabs();
        this.setupMenuButtons();
        this.setupDefaultControls();
    }

    setupPanelToggle() {
        if (this.panelToggle) {
            this.panelToggle.addEventListener('click', () => {
                this.controlPanel.classList.toggle('collapsed');
            });
        }
    }

    setupSectionCollapse() {
        document.querySelectorAll('.section-title').forEach(title => {
            title.addEventListener('click', () => {
                const isCollapsed = title.getAttribute('data-collapsed') === 'true';
                title.setAttribute('data-collapsed', !isCollapsed);

                const content = title.nextElementSibling;
                if (content) {
                    content.classList.toggle('hidden', !isCollapsed);
                }

                const icon = title.querySelector('.collapse-icon');
                if (icon) {
                    icon.textContent = isCollapsed ? '▼' : '▶';
                }
            });
        });
    }

    setupMenuTabs() {
        const tabs = document.querySelectorAll('.menu-tab');
        const views = document.querySelectorAll('.view-container');

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetId = tab.getAttribute('data-tab');

                // Activer l'onglet
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Afficher la vue correspondante
                views.forEach(view => {
                    view.classList.remove('active');
                    if (view.id === `view-${targetId}`) {
                        view.classList.add('active');
                    }
                });

                // Émettre un événement
                this.emitEvent('tabChange', { tab: targetId });
            });
        });
    }

    setupMenuButtons() {
        // Plein écran
        const btnFullscreen = document.getElementById('btn-fullscreen');
        if (btnFullscreen) {
            btnFullscreen.addEventListener('click', () => this.toggleFullscreen());
        }

        // Reset
        const btnReset = document.getElementById('btn-reset');
        if (btnReset) {
            btnReset.addEventListener('click', () => {
                if (this.onReset) this.onReset();
                this.resetToDefaults();
            });
        }

        // Aide
        const btnHelp = document.getElementById('btn-help');
        const helpModal = document.getElementById('help-modal');
        const modalClose = document.getElementById('modal-close');

        if (btnHelp && helpModal) {
            btnHelp.addEventListener('click', () => {
                helpModal.classList.remove('hidden');
            });
        }

        if (modalClose && helpModal) {
            modalClose.addEventListener('click', () => {
                helpModal.classList.add('hidden');
            });

            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) {
                    helpModal.classList.add('hidden');
                }
            });
        }
    }

    setupDefaultControls() {
        // Contrôles d'affichage par défaut
        this.bindCheckbox('show-grid', 'showGrid', true);
        this.bindCheckbox('show-axes', 'showAxes', true);
        this.bindCheckbox('show-labels', 'showLabels', true);
        this.bindCheckbox('show-values', 'showValues', true);

        this.bindRange('font-size', 'fontSize', 18, 'font-size-value', 'px');
        this.bindRange('line-width', 'lineWidth', 2, 'line-width-value', 'px');
    }

    // ==========================================
    // LIAISON DES CONTRÔLES
    // ==========================================

    /**
     * Lie une checkbox à un paramètre
     */
    bindCheckbox(elementId, paramName, defaultValue = false) {
        const element = document.getElementById(elementId);
        if (!element) return;

        // Initialiser
        this.params[paramName] = defaultValue;
        element.checked = defaultValue;

        // Écouter les changements
        element.addEventListener('change', () => {
            this.params[paramName] = element.checked;
            this.notifyChange(paramName, element.checked);
        });

        return element;
    }

    /**
     * Lie un input number à un paramètre
     */
    bindNumber(elementId, paramName, defaultValue, options = {}) {
        const element = document.getElementById(elementId);
        if (!element) return;

        const { min, max, step = 1, displayId, unit = '' } = options;

        // Appliquer les limites
        if (min !== undefined) element.min = min;
        if (max !== undefined) element.max = max;
        element.step = step;

        // Initialiser
        this.params[paramName] = defaultValue;
        element.value = defaultValue;
        this.updateDisplay(displayId, defaultValue, unit);

        // Écouter les changements
        element.addEventListener('input', () => {
            let value = parseFloat(element.value);

            // Valider
            if (isNaN(value)) value = defaultValue;
            if (min !== undefined) value = Math.max(min, value);
            if (max !== undefined) value = Math.min(max, value);

            this.params[paramName] = value;
            this.updateDisplay(displayId, value, unit);
            this.notifyChange(paramName, value);
        });

        return element;
    }

    /**
     * Lie un slider (range) à un paramètre
     */
    bindRange(elementId, paramName, defaultValue, displayId = null, unit = '') {
        const element = document.getElementById(elementId);
        if (!element) return;

        // Initialiser
        this.params[paramName] = defaultValue;
        element.value = defaultValue;
        this.updateDisplay(displayId, defaultValue, unit);

        // Écouter les changements
        element.addEventListener('input', () => {
            const value = parseFloat(element.value);
            this.params[paramName] = value;
            this.updateDisplay(displayId, value, unit);
            this.notifyChange(paramName, value);
        });

        return element;
    }

    /**
     * Lie un select à un paramètre
     */
    bindSelect(elementId, paramName, defaultValue) {
        const element = document.getElementById(elementId);
        if (!element) return;

        // Initialiser
        this.params[paramName] = defaultValue;
        element.value = defaultValue;

        // Écouter les changements
        element.addEventListener('change', () => {
            this.params[paramName] = element.value;
            this.notifyChange(paramName, element.value);
        });

        return element;
    }

    /**
     * Lie un input text à un paramètre
     */
    bindText(elementId, paramName, defaultValue = '') {
        const element = document.getElementById(elementId);
        if (!element) return;

        // Initialiser
        this.params[paramName] = defaultValue;
        element.value = defaultValue;

        // Écouter les changements
        element.addEventListener('input', () => {
            this.params[paramName] = element.value;
            this.notifyChange(paramName, element.value);
        });

        return element;
    }

    /**
     * Lie un color picker à un paramètre
     */
    bindColor(elementId, paramName, defaultValue = '#000000') {
        const element = document.getElementById(elementId);
        if (!element) return;

        // Initialiser
        this.params[paramName] = defaultValue;
        element.value = defaultValue;

        // Écouter les changements
        element.addEventListener('input', () => {
            this.params[paramName] = element.value;
            this.notifyChange(paramName, element.value);
        });

        return element;
    }

    /**
     * Lie un groupe de radio buttons à un paramètre
     */
    bindRadioGroup(name, paramName, defaultValue) {
        const elements = document.querySelectorAll(`input[name="${name}"]`);
        if (elements.length === 0) return;

        // Initialiser
        this.params[paramName] = defaultValue;
        elements.forEach(el => {
            if (el.value === defaultValue) {
                el.checked = true;
            }
        });

        // Écouter les changements
        elements.forEach(el => {
            el.addEventListener('change', () => {
                if (el.checked) {
                    this.params[paramName] = el.value;
                    this.notifyChange(paramName, el.value);
                }
            });
        });

        return elements;
    }

    // ==========================================
    // CRÉATION DYNAMIQUE DE CONTRÔLES
    // ==========================================

    /**
     * Ajoute un groupe de contrôle à une section
     */
    addControlGroup(sectionId, config) {
        const section = document.getElementById(sectionId);
        if (!section) return;

        const group = document.createElement('div');
        group.className = 'control-group';

        switch (config.type) {
            case 'checkbox':
                group.innerHTML = this.createCheckboxHTML(config);
                section.appendChild(group);
                return this.bindCheckbox(config.id, config.param, config.default);

            case 'number':
                group.innerHTML = this.createNumberHTML(config);
                section.appendChild(group);
                return this.bindNumber(config.id, config.param, config.default, config);

            case 'range':
                group.innerHTML = this.createRangeHTML(config);
                section.appendChild(group);
                return this.bindRange(config.id, config.param, config.default, `${config.id}-value`, config.unit);

            case 'select':
                group.innerHTML = this.createSelectHTML(config);
                section.appendChild(group);
                return this.bindSelect(config.id, config.param, config.default);

            case 'text':
                group.innerHTML = this.createTextHTML(config);
                section.appendChild(group);
                return this.bindText(config.id, config.param, config.default);

            case 'color':
                group.innerHTML = this.createColorHTML(config);
                section.appendChild(group);
                return this.bindColor(config.id, config.param, config.default);
        }
    }

    createCheckboxHTML(config) {
        return `
            <label class="checkbox-label">
                <input type="checkbox" id="${config.id}" ${config.default ? 'checked' : ''}>
                <span>${config.label}</span>
            </label>
        `;
    }

    createNumberHTML(config) {
        const attrs = [];
        if (config.min !== undefined) attrs.push(`min="${config.min}"`);
        if (config.max !== undefined) attrs.push(`max="${config.max}"`);
        if (config.step !== undefined) attrs.push(`step="${config.step}"`);

        return `
            <label for="${config.id}">${config.label}</label>
            <input type="number" id="${config.id}" value="${config.default}" ${attrs.join(' ')}>
        `;
    }

    createRangeHTML(config) {
        return `
            <label for="${config.id}">${config.label}</label>
            <input type="range" id="${config.id}"
                   min="${config.min || 0}"
                   max="${config.max || 100}"
                   step="${config.step || 1}"
                   value="${config.default}">
            <span class="value-display" id="${config.id}-value">${config.default}${config.unit || ''}</span>
        `;
    }

    createSelectHTML(config) {
        const options = config.options.map(opt =>
            `<option value="${opt.value}" ${opt.value === config.default ? 'selected' : ''}>${opt.label}</option>`
        ).join('');

        return `
            <label for="${config.id}">${config.label}</label>
            <select id="${config.id}">${options}</select>
        `;
    }

    createTextHTML(config) {
        return `
            <label for="${config.id}">${config.label}</label>
            <input type="text" id="${config.id}" value="${config.default || ''}"
                   placeholder="${config.placeholder || ''}">
        `;
    }

    createColorHTML(config) {
        return `
            <label for="${config.id}">${config.label}</label>
            <input type="color" id="${config.id}" value="${config.default || '#000000'}">
        `;
    }

    // ==========================================
    // GESTION DE L'ÉTAT
    // ==========================================

    /**
     * Obtient la valeur d'un paramètre
     */
    get(paramName) {
        return this.params[paramName];
    }

    /**
     * Définit la valeur d'un paramètre
     */
    set(paramName, value, updateUI = true) {
        this.params[paramName] = value;

        if (updateUI) {
            // Mettre à jour l'élément UI correspondant
            const element = document.getElementById(paramName.replace(/([A-Z])/g, '-$1').toLowerCase());
            if (element) {
                if (element.type === 'checkbox') {
                    element.checked = value;
                } else {
                    element.value = value;
                }
            }
        }

        this.notifyChange(paramName, value);
    }

    /**
     * Obtient tous les paramètres
     */
    getAll() {
        return { ...this.params };
    }

    /**
     * Définit plusieurs paramètres à la fois
     */
    setAll(params) {
        for (const [key, value] of Object.entries(params)) {
            this.set(key, value);
        }
    }

    /**
     * Réinitialise aux valeurs par défaut
     */
    resetToDefaults() {
        // Les valeurs par défaut sont stockées dans les attributs data
        document.querySelectorAll('[data-default]').forEach(el => {
            const defaultValue = el.getAttribute('data-default');
            if (el.type === 'checkbox') {
                el.checked = defaultValue === 'true';
            } else {
                el.value = defaultValue;
            }
            el.dispatchEvent(new Event('input'));
        });
    }

    // ==========================================
    // UTILITAIRES
    // ==========================================

    updateDisplay(displayId, value, unit = '') {
        if (!displayId) return;
        const display = document.getElementById(displayId);
        if (display) {
            display.textContent = MathUtils.format(value, 2) + unit;
        }
    }

    notifyChange(paramName, value) {
        if (this.onChange) {
            this.onChange(paramName, value, this.params);
        }
        this.emitEvent('paramChange', { param: paramName, value, allParams: this.params });
    }

    emitEvent(name, detail) {
        document.dispatchEvent(new CustomEvent(`controls:${name}`, { detail }));
    }

    toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            document.exitFullscreen();
        }
    }

    /**
     * Active/désactive un groupe de contrôles
     */
    setGroupEnabled(groupId, enabled) {
        const group = document.getElementById(groupId);
        if (group) {
            if (enabled) {
                group.classList.remove('disabled');
            } else {
                group.classList.add('disabled');
            }
        }
    }

    /**
     * Affiche/cache une section
     */
    setSectionVisible(sectionId, visible) {
        const section = document.getElementById(sectionId);
        if (section) {
            const sectionParent = section.closest('.control-section');
            if (sectionParent) {
                sectionParent.style.display = visible ? 'block' : 'none';
            }
        }
    }
}

// Export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = Controls;
}


// === render-helpers.js ===

/**
 * RENDER HELPERS
 * Fonctions utilitaires pour le rendu avancé :
 * - TextBox avec fond pour la lisibilité
 * - Rendu MathJax/LaTeX
 * - Effets de transition
 */

// ==========================================
// CONFIGURATION GLOBALE
// ==========================================

const RenderConfig = {
    // Délai en ms à la fin de chaque scène avant transition
    sceneEndDelay: 1500,

    // Durée des transitions
    transitionDuration: 500,

    // Cache pour les éléments MathJax
    mathCache: new Map()
};

// ==========================================
// TEXT BOX - Boîte de texte avec fond
// ==========================================

/**
 * Dessine du texte dans une boîte avec fond pour la lisibilité
 * @param {CanvasRenderer} renderer - Instance du renderer
 * @param {string} text - Texte à afficher
 * @param {number} x - Coordonnée X (repère math)
 * @param {number} y - Coordonnée Y (repère math)
 * @param {Object} options - Options de style
 */
function drawTextBox(renderer, text, x, y, options = {}) {
    const {
        font = '20px Arial',
        color = '#1e3a8a',
        bgColor = 'rgba(255, 255, 255, 0.92)',
        padding = 12,
        borderRadius = 8,
        align = 'center',
        opacity = 1,
        borderColor = null,
        borderWidth = 0,
        shadow = true,
        maxWidth = null
    } = options;

    const ctx = renderer.ctx;
    const canvasPos = renderer.toPixel(x, y);

    // Appliquer l'opacité globale
    ctx.save();
    ctx.globalAlpha = opacity;

    // Mesurer le texte
    ctx.font = font;
    let textWidth = ctx.measureText(text).width;

    // Gérer le texte multi-lignes si nécessaire
    const lines = text.split('\n');
    const lineHeight = parseInt(font) * 1.3;
    const totalHeight = lines.length * lineHeight;

    // Calculer la largeur max si multi-lignes
    textWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
    if (maxWidth && textWidth > maxWidth) {
        textWidth = maxWidth;
    }

    // Position de la boîte selon l'alignement
    let boxX = canvasPos.x - textWidth / 2 - padding;
    if (align === 'left') {
        boxX = canvasPos.x - padding;
    } else if (align === 'right') {
        boxX = canvasPos.x - textWidth - padding;
    }
    const boxY = canvasPos.y - totalHeight / 2 - padding;
    const boxWidth = textWidth + 2 * padding;
    const boxHeight = totalHeight + 2 * padding;

    // Ombre
    if (shadow) {
        ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 4;
    }

    // Dessiner le fond
    ctx.fillStyle = bgColor;
    ctx.beginPath();
    if (ctx.roundRect) {
        ctx.roundRect(boxX, boxY, boxWidth, boxHeight, borderRadius);
    } else {
        // Fallback pour navigateurs sans roundRect
        drawRoundRect(ctx, boxX, boxY, boxWidth, boxHeight, borderRadius);
    }
    ctx.fill();

    // Réinitialiser l'ombre pour le texte
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // Bordure optionnelle
    if (borderColor && borderWidth > 0) {
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = borderWidth;
        ctx.stroke();
    }

    // Dessiner le texte
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    let textX = canvasPos.x;
    if (align === 'left') {
        ctx.textAlign = 'left';
        textX = canvasPos.x;
    } else if (align === 'right') {
        ctx.textAlign = 'right';
        textX = canvasPos.x;
    }

    // Dessiner chaque ligne
    lines.forEach((line, i) => {
        const lineY = canvasPos.y - (totalHeight / 2) + (i + 0.5) * lineHeight;
        ctx.fillText(line, textX, lineY);
    });

    ctx.restore();
}

/**
 * Dessine un rectangle arrondi (fallback)
 */
function drawRoundRect(ctx, x, y, width, height, radius) {
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
}

// ==========================================
// RESULT BOX - Boîte de résultat mise en valeur
// ==========================================

/**
 * Dessine une boîte de résultat mise en valeur (pour les conclusions)
 * @param {CanvasRenderer} renderer - Instance du renderer
 * @param {string} text - Résultat à afficher
 * @param {number} x - Coordonnée X (repère math)
 * @param {number} y - Coordonnée Y (repère math)
 * @param {Object} options - Options de style
 */
function drawResultBox(renderer, text, x, y, options = {}) {
    const {
        font = 'bold 24px Arial',
        color = '#059669',
        bgColor = 'rgba(209, 250, 229, 0.98)',
        borderColor = '#10b981',
        opacity = 1
    } = options;

    drawTextBox(renderer, text, x, y, {
        font,
        color,
        bgColor,
        padding: 16,
        borderRadius: 10,
        align: 'center',
        opacity,
        borderColor,
        borderWidth: 3,
        shadow: true
    });
}

// ==========================================
// MATHJAX OVERLAY MANAGER
// ==========================================

const MathOverlay = {
    container: null,
    elements: new Map(),      // id -> { element, active }
    renderer: null,
    pendingTypesets: new Set(),
    currentSceneId: null,

    /**
     * Initialise l'overlay MathJax
     */
    init(renderer) {
        this.container = document.getElementById('math-overlay');
        this.renderer = renderer;
        return this;
    },

    /**
     * Debut de frame - marque tous les elements comme inactifs
     */
    beginFrame() {
        this.elements.forEach(data => {
            data.active = false;
        });
    },

    /**
     * Fin de frame - supprime les elements non utilises
     */
    endFrame() {
        const toRemove = [];
        this.elements.forEach((data, id) => {
            if (!data.active) {
                toRemove.push(id);
            }
        });
        toRemove.forEach(id => {
            const data = this.elements.get(id);
            if (data && data.element) {
                data.element.remove();
            }
            this.elements.delete(id);
        });
    },

    /**
     * Efface tous les éléments MathJax (changement de scene)
     */
    clear() {
        if (this.container) {
            this.container.innerHTML = '';
        }
        this.elements.clear();
        this.pendingTypesets.clear();
    },

    /**
     * Affiche une formule LaTeX à une position donnée
     * @param {string} id - Identifiant unique pour l'élément
     * @param {string} latex - Code LaTeX
     * @param {number} x - Coordonnée X (repère math)
     * @param {number} y - Coordonnée Y (repère math)
     * @param {Object} options - Options
     */
    showMath(id, latex, x, y, options = {}) {
        if (!this.container || !this.renderer) return;

        const {
            color = '#1e3a8a',
            fontSize = '1.4em',
            bgColor = 'rgba(255, 255, 255, 0.95)',
            padding = '12px 18px',
            borderRadius = '10px',
            opacity = 1,
            animate = false,
            isResult = false,
            borderColor = null,
            borderWidth = 0,
            shadow = true,
            align = 'center'
        } = options;

        // Convertir en pixels
        const pos = this.renderer.toPixel(x, y);

        // Verifier si l'element existe deja
        let data = this.elements.get(id);
        let element;
        const isNew = !data;

        if (isNew) {
            element = document.createElement('div');
            element.className = 'math-element';
            if (animate) element.classList.add('fade-in');
            if (isResult) element.classList.add('math-result-box');
            element.id = `math-${id}`;
            this.container.appendChild(element);
            data = { element, active: true };
            this.elements.set(id, data);
        } else {
            element = data.element;
            data.active = true; // Marquer comme actif pour cette frame
        }

        // Positionner l'élément
        element.style.left = `${pos.x}px`;
        element.style.top = `${pos.y}px`;
        element.style.opacity = opacity;
        element.style.color = color;
        element.style.fontSize = fontSize;
        element.style.background = bgColor;
        element.style.padding = padding;
        element.style.borderRadius = borderRadius;

        // Bordure optionnelle
        if (borderColor && borderWidth > 0) {
            element.style.border = `${borderWidth}px solid ${borderColor}`;
        }

        // Ombre
        if (shadow) {
            element.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';
        }

        // Alignement
        if (align === 'left') {
            element.style.transform = 'translateY(-50%)';
        } else if (align === 'right') {
            element.style.transform = 'translate(-100%, -50%)';
        }

        // Mettre à jour le contenu si nécessaire
        const currentLatex = element.getAttribute('data-latex');
        if (currentLatex !== latex) {
            element.setAttribute('data-latex', latex);
            element.innerHTML = `\\(${latex}\\)`;

            // Re-rendre avec MathJax (avec debounce)
            if (window.MathJax && window.MathJax.typesetPromise && !this.pendingTypesets.has(id)) {
                this.pendingTypesets.add(id);
                requestAnimationFrame(() => {
                    if (this.elements.has(id)) {
                        window.MathJax.typesetPromise([element]).then(() => {
                            this.pendingTypesets.delete(id);
                        }).catch(err => {
                            console.warn('MathJax rendering error:', err);
                            this.pendingTypesets.delete(id);
                        });
                    }
                });
            }
        }
    },

    /**
     * Affiche une formule dans une boite mise en valeur (resultat)
     */
    showResult(id, latex, x, y, options = {}) {
        this.showMath(id, latex, x, y, {
            fontSize: '1.6em',
            color: '#059669',
            bgColor: 'rgba(209, 250, 229, 0.98)',
            borderColor: '#10b981',
            borderWidth: 3,
            padding: '14px 22px',
            isResult: true,
            ...options
        });
    },

    /**
     * Cache un element MathJax
     */
    hideMath(id) {
        const data = this.elements.get(id);
        if (data && data.element) {
            data.element.classList.remove('fade-in');
            data.element.classList.add('fade-out');
            setTimeout(() => {
                data.element.remove();
                this.elements.delete(id);
            }, 300);
        }
    },

    /**
     * Met à jour les positions (après resize)
     */
    updatePositions() {
        // Peut être appelé après un redimensionnement
    }
};

// ==========================================
// DRAW MATH BOX - Formule LaTeX avec fond
// ==========================================

/**
 * Affiche une formule LaTeX avec fond via MathJax overlay
 * @param {string} id - Identifiant unique
 * @param {string} latex - Code LaTeX (sans les delimiteurs)
 * @param {number} x - Coordonnée X (repère math)
 * @param {number} y - Coordonnée Y (repère math)
 * @param {Object} options - Options de style
 */
function drawMathBox(id, latex, x, y, options = {}) {
    MathOverlay.showMath(id, latex, x, y, options);
}

/**
 * Affiche un résultat LaTeX mis en valeur
 * @param {string} id - Identifiant unique
 * @param {string} latex - Code LaTeX (sans les delimiteurs)
 * @param {number} x - Coordonnée X (repère math)
 * @param {number} y - Coordonnée Y (repère math)
 * @param {Object} options - Options de style
 */
function drawMathResult(id, latex, x, y, options = {}) {
    MathOverlay.showResult(id, latex, x, y, options);
}

// ==========================================
// GESTIONNAIRE DE TRANSITIONS
// ==========================================

const TransitionManager = {
    transitionElement: null,
    isTransitioning: false,

    init() {
        this.transitionElement = document.getElementById('scene-transition');
        return this;
    },

    /**
     * Affiche une transition vers une nouvelle scène
     * @param {string} title - Titre de la scène
     * @param {string} subtitle - Sous-titre optionnel
     * @param {number} duration - Durée en ms
     */
    show(title, subtitle = '', duration = 1000) {
        if (!this.transitionElement) return Promise.resolve();

        return new Promise(resolve => {
            const content = this.transitionElement.querySelector('.transition-content');
            content.innerHTML = `
                <div class="scene-title">${title}</div>
                ${subtitle ? `<div class="scene-subtitle">${subtitle}</div>` : ''}
            `;

            this.transitionElement.classList.remove('hidden');
            this.transitionElement.classList.add('active');
            this.isTransitioning = true;

            setTimeout(() => {
                this.hide();
                resolve();
            }, duration);
        });
    },

    /**
     * Cache la transition
     */
    hide() {
        if (!this.transitionElement) return;

        this.transitionElement.classList.remove('active');
        this.isTransitioning = false;

        setTimeout(() => {
            if (!this.isTransitioning) {
                this.transitionElement.classList.add('hidden');
            }
        }, 500);
    }
};

// ==========================================
// HELPERS D'ANIMATION AVEC TRANSITION
// ==========================================

/**
 * Calcule la progression effective avec délai de fin
 * @param {number} progress - Progression brute (0-1)
 * @param {number} contentEnd - Quand le contenu finit (0-1), ex: 0.85
 * @returns {Object} { contentProgress, isInDelay, delayProgress }
 */
function getProgressWithDelay(progress, contentEnd = 0.85) {
    if (progress < contentEnd) {
        return {
            contentProgress: progress / contentEnd,
            isInDelay: false,
            delayProgress: 0
        };
    } else {
        return {
            contentProgress: 1,
            isInDelay: true,
            delayProgress: (progress - contentEnd) / (1 - contentEnd)
        };
    }
}

/**
 * Crée un effet de fondu entrant
 * @param {number} progress - Progression (0-1)
 * @param {number} start - Début du fondu
 * @param {number} end - Fin du fondu
 * @param {string} easing - Type d'easing
 */
function fadeIn(progress, start = 0, end = 0.3, easing = 'easeOutQuad') {
    if (progress < start) return 0;
    if (progress > end) return 1;
    const p = (progress - start) / (end - start);
    return MathUtils.ease(p, easing);
}

/**
 * Crée un effet de fondu sortant
 */
function fadeOut(progress, start = 0.7, end = 1, easing = 'easeInQuad') {
    if (progress < start) return 1;
    if (progress > end) return 0;
    const p = (progress - start) / (end - start);
    return 1 - MathUtils.ease(p, easing);
}

/**
 * Crée un effet de glissement vertical
 */
function slideIn(progress, start = 0, end = 0.3, offset = 0.5, easing = 'easeOutCubic') {
    if (progress < start) return offset;
    if (progress > end) return 0;
    const p = (progress - start) / (end - start);
    return offset * (1 - MathUtils.ease(p, easing));
}

// ==========================================
// EXPORTS GLOBAUX
// ==========================================

// Rendre les fonctions disponibles globalement
window.drawTextBox = drawTextBox;
window.drawResultBox = drawResultBox;
window.drawMathBox = drawMathBox;
window.drawMathResult = drawMathResult;
window.MathOverlay = MathOverlay;
window.TransitionManager = TransitionManager;
window.RenderConfig = RenderConfig;
window.getProgressWithDelay = getProgressWithDelay;
window.fadeIn = fadeIn;
window.fadeOut = fadeOut;
window.slideIn = slideIn;


// === animation-logic.js ===

/**
 * ANIMATION LOGIC
 * ================
 * Ce fichier contient la logique spécifique de l'animation.
 * C'est le fichier principal à modifier pour implémenter l'animation.
 *
 * STRUCTURE À SUIVRE:
 * 1. Définir les paramètres spécifiques dans AnimationLogic.params
 * 2. Implémenter setupControls() pour créer les contrôles UI
 * 3. Implémenter update() pour la logique de mise à jour
 * 4. Implémenter render() pour le dessin sur le canvas
 * 5. Implémenter getInfoDisplay() pour les informations affichées
 */

const AnimationLogic = {
    // ==========================================
    // PARAMÈTRES DE L'ANIMATION
    // ==========================================
    params: {
        // === PARAMÈTRES PRINCIPAUX ===
        x_u: 4,
        y_u: 0,
        x_v: 3,
        y_v: 3,
        showProjection: true,
        formulaMode: 'analytique', // 'geometrique', 'analytique', 'projection'

        // === PARAMÈTRES D'AFFICHAGE ===
        // (gérés automatiquement par Controls)
    },

    // État interne de l'animation
    state: {
        // Valeurs calculées
        normU: 0,
        normV: 0,
        dotProduct: 0,
        angle: 0,
        angleDeg: 0,
        projectionH: { x: 0, y: 0 }
    },

    // Références aux objets principaux (injectés par main.js)
    renderer: null,
    animation: null,
    controls: null,

    // ==========================================
    // INITIALISATION
    // ==========================================

    /**
     * Initialise l'animation
     * Appelé une fois au démarrage
     */
    init(renderer, animation, controls) {
        this.renderer = renderer;
        this.animation = animation;
        this.controls = controls;

        // Configurer les contrôles spécifiques
        this.setupControls();

        // Initialiser l'état
        this.resetState();

        console.log('[AnimationLogic] Initialized');
    },

    /**
     * Configure les contrôles spécifiques à l'animation
     * Ajouter ici tous les contrôles de la section "Paramètres principaux"
     */
    setupControls() {
        // === VECTEUR U ===
        this.controls.addControlGroup('params-principaux', {
            type: 'range',
            id: 'x_u',
            param: 'x_u',
            label: 'x_u (composante x de u)',
            min: -5,
            max: 5,
            step: 0.5,
            default: this.params.x_u,
            unit: ''
        });

        this.controls.addControlGroup('params-principaux', {
            type: 'range',
            id: 'y_u',
            param: 'y_u',
            label: 'y_u (composante y de u)',
            min: -5,
            max: 5,
            step: 0.5,
            default: this.params.y_u,
            unit: ''
        });

        // === VECTEUR V ===
        this.controls.addControlGroup('params-principaux', {
            type: 'range',
            id: 'x_v',
            param: 'x_v',
            label: 'x_v (composante x de v)',
            min: -5,
            max: 5,
            step: 0.5,
            default: this.params.x_v,
            unit: ''
        });

        this.controls.addControlGroup('params-principaux', {
            type: 'range',
            id: 'y_v',
            param: 'y_v',
            label: 'y_v (composante y de v)',
            min: -5,
            max: 5,
            step: 0.5,
            default: this.params.y_v,
            unit: ''
        });

        // === OPTIONS D'AFFICHAGE ===
        this.controls.addControlGroup('params-principaux', {
            type: 'checkbox',
            id: 'show-projection',
            param: 'showProjection',
            label: 'Afficher la projection',
            default: this.params.showProjection
        });

        this.controls.addControlGroup('params-principaux', {
            type: 'select',
            id: 'formula-mode',
            param: 'formulaMode',
            label: 'Mode de formule',
            default: this.params.formulaMode,
            options: [
                { value: 'geometrique', label: 'Géométrique' },
                { value: 'analytique', label: 'Analytique' },
                { value: 'projection', label: 'Projection' }
            ]
        });

        // === ÉCOUTER LES CHANGEMENTS DE PARAMÈTRES ===
        this.controls.onChange = (param, value, allParams) => {
            this.onParamChange(param, value);
        };
    },

    /**
     * Réinitialise l'état de l'animation
     */
    resetState() {
        this.state = {
            // Réinitialiser toutes les variables d'état
        };
    },

    // ==========================================
    // MISE À JOUR
    // ==========================================

    /**
     * Met à jour l'animation à chaque frame
     * @param {number} deltaTime - Temps écoulé depuis la dernière frame (ms)
     * @param {number} elapsedTime - Temps total écoulé (ms)
     */
    update(deltaTime, elapsedTime) {
        // === CALCULS DES VALEURS ===
        const ux = this.params.x_u;
        const uy = this.params.y_u;
        const vx = this.params.x_v;
        const vy = this.params.y_v;

        // Normes
        this.state.normU = Math.sqrt(ux * ux + uy * uy);
        this.state.normV = Math.sqrt(vx * vx + vy * vy);

        // Produit scalaire
        this.state.dotProduct = ux * vx + uy * vy;

        // Angle (gérer le cas où les vecteurs sont nuls)
        if (this.state.normU > 0.01 && this.state.normV > 0.01) {
            const cosAngle = this.state.dotProduct / (this.state.normU * this.state.normV);
            // Borner entre -1 et 1 pour éviter les erreurs d'arrondi
            this.state.angle = Math.acos(Math.max(-1, Math.min(1, cosAngle)));
            this.state.angleDeg = this.state.angle * 180 / Math.PI;
        } else {
            this.state.angle = 0;
            this.state.angleDeg = 0;
        }

        // Projection de v sur u : H = (u·v / ||u||²) × u
        if (this.state.normU > 0.01) {
            const projScalar = this.state.dotProduct / (this.state.normU * this.state.normU);
            this.state.projectionH = {
                x: projScalar * ux,
                y: projScalar * uy
            };
        } else {
            this.state.projectionH = { x: 0, y: 0 };
        }
    },

    /**
     * Appelé quand un paramètre change
     * @param {string} param - Nom du paramètre modifié
     * @param {*} value - Nouvelle valeur
     */
    onParamChange(param, value) {
        // Mettre à jour les paramètres internes
        if (this.params.hasOwnProperty(param)) {
            this.params[param] = value;
        }

        // Actions spécifiques selon le paramètre
        /*
        switch (param) {
            case 'amplitude':
                // Réagir au changement d'amplitude
                break;
            case 'frequency':
                // Réagir au changement de fréquence
                break;
        }
        */
    },

    // ==========================================
    // RENDU
    // ==========================================

    /**
     * Dessine l'animation
     * @param {CanvasRenderer} renderer - Instance du renderer
     */
    render(renderer) {
        const ux = this.params.x_u;
        const uy = this.params.y_u;
        const vx = this.params.x_v;
        const vy = this.params.y_v;

        // === DESSINER LES VECTEURS ===
        // Vecteur u (rouge)
        if (this.state.normU > 0.01) {
            renderer.drawVector(0, 0, ux, uy, {
                color: '#ef4444',
                width: 3
            });
            renderer.drawText('u', ux + 0.3, uy + 0.3, {
                color: '#ef4444',
                font: 'bold 24px Arial'
            });
        }

        // Vecteur v (bleu)
        if (this.state.normV > 0.01) {
            renderer.drawVector(0, 0, vx, vy, {
                color: '#3b82f6',
                width: 3
            });
            renderer.drawText('v', vx + 0.3, vy + 0.3, {
                color: '#3b82f6',
                font: 'bold 24px Arial'
            });
        }

        // === AFFICHER L'ANGLE ===
        if (this.state.normU > 0.01 && this.state.normV > 0.01) {
            // Calculer l'angle de départ (u) et l'angle d'arrivée (v)
            const angleU = Math.atan2(uy, ux);
            const angleV = Math.atan2(vy, vx);

            // Arc entre les deux vecteurs
            let startAngle = Math.min(angleU, angleV);
            let endAngle = Math.max(angleU, angleV);

            // Ajuster si l'arc traverse 0
            if (endAngle - startAngle > Math.PI) {
                [startAngle, endAngle] = [endAngle, startAngle + 2 * Math.PI];
            }

            renderer.drawArc(0, 0, 1, startAngle, endAngle, {
                color: '#10b981',
                lineWidth: 2
            });
        }

        // === PROJECTION ORTHOGONALE ===
        if (this.params.showProjection && this.state.normU > 0.01 && this.state.normV > 0.01) {
            const hx = this.state.projectionH.x;
            const hy = this.state.projectionH.y;

            // Segment perpendiculaire de V vers H
            renderer.drawSegment(vx, vy, hx, hy, {
                color: '#9b59b6',
                width: 2,
                dashed: true
            });

            // Point H
            renderer.drawPoint(hx, hy, {
                radius: 6,
                color: '#9b59b6'
            });
            renderer.drawText('H', hx, hy - 0.5, {
                color: '#9b59b6',
                font: 'bold 20px Arial',
                align: 'center'
            });

            // Vecteur OH
            renderer.drawVector(0, 0, hx, hy, {
                color: '#9b59b6',
                width: 2
            });
        }

        // === FORMULE SELON LE MODE ===
        let formula = '';
        let formulaColor = '#2563eb';

        if (this.state.normU > 0.01 && this.state.normV > 0.01) {
            switch (this.params.formulaMode) {
                case 'geometrique':
                    formula = `u · v = ||u|| × ||v|| × cos(θ) = ${MathUtils.format(this.state.dotProduct, 2)}`;
                    formulaColor = '#10b981';
                    break;
                case 'analytique':
                    formula = `u · v = xu × xv + yu × yv = ${MathUtils.format(this.state.dotProduct, 2)}`;
                    formulaColor = '#3b82f6';
                    break;
                case 'projection':
                    const oh = Math.sqrt(this.state.projectionH.x ** 2 + this.state.projectionH.y ** 2);
                    formula = `u · v = ||u|| × OH = ${MathUtils.format(this.state.dotProduct, 2)}`;
                    formulaColor = '#9b59b6';
                    break;
            }

            renderer.drawText(formula, 0, -5, {
                color: formulaColor,
                font: 'bold 22px Arial',
                align: 'center'
            });
        }
    },

    // ==========================================
    // AFFICHAGE D'INFORMATIONS
    // ==========================================

    /**
     * Retourne les informations à afficher dans l'overlay
     * @returns {Array} Tableau d'objets { label, value }
     */
    getInfoDisplay() {
        const info = [];

        // Coordonnées des vecteurs
        info.push({
            label: 'u',
            value: `(${MathUtils.format(this.params.x_u, 1)}, ${MathUtils.format(this.params.y_u, 1)})`
        });

        info.push({
            label: 'v',
            value: `(${MathUtils.format(this.params.x_v, 1)}, ${MathUtils.format(this.params.y_v, 1)})`
        });

        // Normes
        if (this.state.normU > 0.01) {
            info.push({
                label: '||u||',
                value: MathUtils.format(this.state.normU, 2)
            });
        }

        if (this.state.normV > 0.01) {
            info.push({
                label: '||v||',
                value: MathUtils.format(this.state.normV, 2)
            });
        }

        // Angle
        if (this.state.normU > 0.01 && this.state.normV > 0.01) {
            info.push({
                label: 'Angle θ',
                value: MathUtils.format(this.state.angleDeg, 1) + '°'
            });
        }

        // Produit scalaire avec couleur selon le signe
        if (this.state.normU > 0.01 && this.state.normV > 0.01) {
            let color, interpretation;

            if (Math.abs(this.state.dotProduct) < 0.1) {
                color = '#3b82f6'; // Bleu
                interpretation = 'Angle droit';
            } else if (this.state.dotProduct > 0) {
                color = '#10b981'; // Vert
                interpretation = 'Angle aigu';
            } else {
                color = '#f97316'; // Orange
                interpretation = 'Angle obtus';
            }

            info.push({
                label: 'u · v',
                value: MathUtils.format(this.state.dotProduct, 2),
                color: color,
                bold: true
            });

            info.push({
                label: 'Interprétation',
                value: interpretation,
                color: color
            });
        }

        return info;
    },

    /**
     * Retourne le contenu HTML de l'aide
     * @returns {string} HTML de l'aide
     */
    getHelpContent() {
        return `
            <h3>Description</h3>
            <p>
                Cette animation interactive permet d'explorer le <strong>produit scalaire</strong> entre deux vecteurs.
                Elle présente les trois définitions équivalentes : géométrique, analytique et par projection orthogonale.
            </p>

            <h3>Contrôles</h3>
            <ul>
                <li><strong>x_u, y_u</strong> : Composantes du vecteur u (rouge)</li>
                <li><strong>x_v, y_v</strong> : Composantes du vecteur v (bleu)</li>
                <li><strong>Afficher la projection</strong> : Montre la projection orthogonale de v sur u</li>
                <li><strong>Mode de formule</strong> : Choisir quelle formule afficher (géométrique, analytique ou projection)</li>
                <li><strong>Options d'affichage</strong> : Personnalisez l'apparence (grille, axes, labels...)</li>
            </ul>

            <h3>Mode Animation</h3>
            <p>
                Passez en mode "Animation" pour voir une présentation séquentielle complète :
                introduction, normes, angle, calculs, projection, orthogonalité et récapitulatif.
            </p>

            <h3>Propriétés importantes</h3>
            <ul>
                <li><strong>Formule géométrique</strong> : u · v = ||u|| × ||v|| × cos(θ)</li>
                <li><strong>Formule analytique</strong> : u · v = xu × xv + yu × yv</li>
                <li><strong>Orthogonalité</strong> : u ⊥ v si et seulement si u · v = 0</li>
                <li><strong>Signe du produit scalaire</strong> :
                    <ul>
                        <li>Positif → angle aigu (θ < 90°)</li>
                        <li>Nul → angle droit (θ = 90°)</li>
                        <li>Négatif → angle obtus (θ > 90°)</li>
                    </ul>
                </li>
            </ul>
        `;
    }
};

// Export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = AnimationLogic;
}


// === index.js ===

/**
 * Index des scènes - Produit Scalaire
 *
 * Helpers et registre pour les scènes
 */

// Registre global des scènes
window.SCENE_REGISTRY = window.SCENE_REGISTRY || [];

/**
 * Helper pour dessiner une boîte de texte avec fond
 * Garantit la lisibilité sur projection
 */
function drawTextBox(renderer, text, x, y, options = {}) {
    const {
        font = '20px Arial',
        color = '#1e3a8a',
        bgColor = 'rgba(255, 255, 255, 0.92)',
        padding = 10,
        borderRadius = 6,
        align = 'center',
        opacity = 1
    } = options;

    const ctx = renderer.ctx;
    ctx.save();

    // Appliquer l'opacité globale
    ctx.globalAlpha = opacity;

    ctx.font = font;
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    const textHeight = parseInt(font) * 1.2;

    // Convertir coordonnées math → canvas
    const canvasPos = renderer.toPixel(x, y);

    // Ajuster selon l'alignement
    let boxX;
    if (align === 'left') {
        boxX = canvasPos.x - padding;
    } else if (align === 'right') {
        boxX = canvasPos.x - textWidth - padding;
    } else {
        boxX = canvasPos.x - textWidth / 2 - padding;
    }
    const boxY = canvasPos.y - textHeight / 2 - padding;

    // Dessiner le fond avec coins arrondis
    ctx.fillStyle = bgColor;
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, textWidth + 2 * padding, textHeight + 2 * padding, borderRadius);
    ctx.fill();

    // Bordure subtile
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.restore();

    // Dessiner le texte
    renderer.drawText(text, x, y, { font, color: opacity < 1 ? color.replace(')', `, ${opacity})`).replace('rgb', 'rgba') : color, align });
}

/**
 * Helper pour dessiner plusieurs lignes de texte dans une boîte
 */
function drawMultilineTextBox(renderer, lines, x, y, options = {}) {
    const {
        font = '20px Arial',
        color = '#1e3a8a',
        bgColor = 'rgba(255, 255, 255, 0.92)',
        padding = 12,
        borderRadius = 6,
        lineSpacing = 1.3,
        align = 'left',
        opacity = 1
    } = options;

    const ctx = renderer.ctx;
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.font = font;

    const fontSize = parseInt(font);
    let maxWidth = 0;
    lines.forEach(line => {
        const w = ctx.measureText(line).width;
        if (w > maxWidth) maxWidth = w;
    });
    const totalHeight = lines.length * fontSize * lineSpacing;

    const canvasPos = renderer.toPixel(x, y);

    // Position de la boîte
    let boxX;
    if (align === 'left') {
        boxX = canvasPos.x - padding;
    } else if (align === 'right') {
        boxX = canvasPos.x - maxWidth - padding;
    } else {
        boxX = canvasPos.x - maxWidth / 2 - padding;
    }
    const boxY = canvasPos.y - padding;

    // Dessiner le fond
    ctx.fillStyle = bgColor;
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, maxWidth + 2 * padding, totalHeight + 2 * padding, borderRadius);
    ctx.fill();

    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.restore();

    // Dessiner chaque ligne
    lines.forEach((line, i) => {
        const lineY = y - (i * fontSize * lineSpacing) / renderer.config.scale;
        renderer.drawText(line, x, lineY, {
            font,
            color: opacity < 1 ? `rgba(30, 58, 138, ${opacity})` : color,
            align
        });
    });
}

// Exposer les helpers globalement
window.TextBoxHelpers = {
    drawTextBox,
    drawMultilineTextBox
};

// Raccourcis pratiques
window.drawTextBox = drawTextBox;
window.drawMultilineTextBox = drawMultilineTextBox;


// === 01-intro.js ===

/**
 * Scène 1 : Introduction
 * Titre "Le Produit Scalaire" qui apparaît progressivement
 */

window.SCENE_REGISTRY.push({
    id: 'intro',
    title: 'Introduction',
    duration: 6000,

    animate(localTime, progress, renderer, state) {
        const { contentProgress } = getProgressWithDelay(progress, 0.70);
        const opacity = MathUtils.ease(contentProgress, 'easeOutQuad');

        // Titre principal au centre
        drawTextBox(renderer, 'Le Produit Scalaire', 0, 0.5, {
            font: 'bold 52px Arial',
            color: '#2563eb',
            align: 'center',
            opacity
        });

        // Sous-titre
        if (contentProgress > 0.5) {
            const subOpacity = MathUtils.ease((contentProgress - 0.5) / 0.5, 'easeOutQuad');
            drawTextBox(renderer, 'Première Specialite', 0, -0.8, {
                font: '24px Arial',
                color: '#64748b',
                align: 'center',
                opacity: subOpacity
            });
        }
    }
});


// === 02-norme.js ===

/**
 * Scene 2 : Norme d'un vecteur
 * Vecteur u(4,3), triangle rectangle, calcul de ||u|| = 5
 * Utilise MathJax pour un rendu LaTeX parfait
 */

window.SCENE_REGISTRY.push({
    id: 'norme',
    title: 'Norme d\'un vecteur',
    duration: 14000,

    animate(localTime, progress, renderer, state) {
        const { contentProgress } = getProgressWithDelay(progress, 0.70);
        const ux = 4, uy = 3;

        // Phase 1 : Apparition du vecteur (0-30%)
        if (contentProgress < 0.3) {
            const p = contentProgress / 0.3;
            const len = MathUtils.ease(p, 'easeOutQuad');

            renderer.drawVector(0, 0, ux * len, uy * len, {
                color: '#ef4444',
                width: 3
            });

            if (p > 0.5) {
                const labelOpacity = MathUtils.ease((p - 0.5) / 0.5, 'easeOutQuad');
                drawMathBox('vec-u-label', '\\vec{u}', ux * len + 0.4, uy * len + 0.4, {
                    opacity: labelOpacity, fontSize: '1.3em', color: '#ef4444',
                    bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
                });
            }
        }
        // Phase 2 : Triangle rectangle (30-60%)
        else if (contentProgress < 0.6) {
            const p = (contentProgress - 0.3) / 0.3;

            // Vecteur complet
            renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
            drawMathBox('vec-u-label', '\\vec{u}', ux + 0.4, uy + 0.4, {
                fontSize: '1.3em', color: '#ef4444',
                bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
            });

            // Triangle rectangle
            const triangleOpacity = MathUtils.ease(p, 'easeOutQuad');
            renderer.drawSegment(0, 0, ux, 0, {
                color: `rgba(59, 130, 246, ${triangleOpacity})`,
                width: 2, dashed: true
            });
            renderer.drawSegment(ux, 0, ux, uy, {
                color: `rgba(59, 130, 246, ${triangleOpacity})`,
                width: 2, dashed: true
            });

            // Labels des cotes
            if (p > 0.3) {
                const labelOp = MathUtils.ease((p - 0.3) / 0.7, 'easeOutQuad');
                drawMathBox('side-x', '4', ux / 2, -0.6, {
                    opacity: labelOp, fontSize: '1.1em', color: '#3b82f6'
                });
                drawMathBox('side-y', '3', ux + 0.7, uy / 2, {
                    opacity: labelOp, fontSize: '1.1em', color: '#3b82f6'
                });
            }
        }
        // Phase 3 : Formule et calcul (60-100%)
        else {
            const p = (contentProgress - 0.6) / 0.4;

            // Elements graphiques
            renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
            drawMathBox('vec-u-label', '\\vec{u}', ux + 0.4, uy + 0.4, {
                fontSize: '1.3em', color: '#ef4444',
                bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
            });
            renderer.drawSegment(0, 0, ux, 0, { color: 'rgba(59, 130, 246, 0.7)', width: 2, dashed: true });
            renderer.drawSegment(ux, 0, ux, uy, { color: 'rgba(59, 130, 246, 0.7)', width: 2, dashed: true });
            drawMathBox('side-x', '4', ux / 2, -0.6, { fontSize: '1.1em', color: '#3b82f6' });
            drawMathBox('side-y', '3', ux + 0.7, uy / 2, { fontSize: '1.1em', color: '#3b82f6' });

            // Formules LaTeX a GAUCHE
            const formulas = [
                { latex: '\\|\\vec{u}\\| = \\sqrt{x^2 + y^2}', isFormula: true },
                { latex: '\\|\\vec{u}\\| = \\sqrt{4^2 + 3^2}', isFormula: false },
                { latex: '\\|\\vec{u}\\| = \\sqrt{16 + 9}', isFormula: false },
                { latex: '\\|\\vec{u}\\| = \\sqrt{25} = 5', isResult: true }
            ];

            const lineDelay = 0.2;
            formulas.forEach((formula, i) => {
                const lineStart = i * lineDelay;
                if (p > lineStart) {
                    const lineProgress = Math.min((p - lineStart) / lineDelay, 1);
                    const opacity = MathUtils.ease(lineProgress, 'easeOutQuad');

                    if (formula.isResult) {
                        drawMathResult(`norm-${i}`, formula.latex, -9, 3 - i * 1.5, {
                            opacity, align: 'left'
                        });
                    } else {
                        drawMathBox(`norm-${i}`, formula.latex, -9, 3 - i * 1.5, {
                            opacity, align: 'left',
                            fontSize: formula.isFormula ? '1.3em' : '1.2em',
                            color: formula.isFormula ? '#1e3a8a' : '#374151',
                            bgColor: formula.isFormula ? 'rgba(219, 234, 254, 0.95)' : 'rgba(255, 255, 255, 0.95)'
                        });
                    }
                }
            });
        }

        state.uNorm = 5;
    }
});


// === 03-deux-vecteurs.js ===

/**
 * Scene 3 : Deux vecteurs
 * Vecteur u(4,0) puis v(3,3) qui apparait en rotation
 * Utilise MathJax pour un rendu LaTeX parfait
 */

window.SCENE_REGISTRY.push({
    id: 'deux-vecteurs',
    title: 'Deux vecteurs',
    duration: 10000,

    animate(localTime, progress, renderer, state) {
        const { contentProgress } = getProgressWithDelay(progress, 0.70);
        const ux = 4, uy = 0;
        const vx = 3, vy = 3;

        // Phase 1 : Vecteur u (0-40%)
        if (contentProgress < 0.4) {
            const p = contentProgress / 0.4;
            const len = MathUtils.ease(p, 'easeOutQuad');

            renderer.drawVector(0, 0, ux * len, uy * len, {
                color: '#ef4444',
                width: 3
            });

            if (p > 0.5) {
                const labelOpacity = MathUtils.ease((p - 0.5) / 0.5, 'easeOutQuad');
                drawMathBox('vec-u-label', '\\vec{u}', ux * len + 0.4, 0.4, {
                    opacity: labelOpacity, fontSize: '1.3em', color: '#ef4444',
                    bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
                });
            }
        }
        // Phase 2 : Vecteur v apparait (40-100%)
        else {
            const p = (contentProgress - 0.4) / 0.6;

            // Vecteur u complet
            renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
            drawMathBox('vec-u-label', '\\vec{u}', ux + 0.4, 0.4, {
                fontSize: '1.3em', color: '#ef4444',
                bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
            });

            // Vecteur v avec rotation depuis l'axe x
            const vLen = Math.sqrt(vx * vx + vy * vy);
            const targetAngle = Math.atan2(vy, vx);
            const currentAngle = MathUtils.ease(Math.min(p * 1.5, 1), 'easeOutQuad') * targetAngle;
            const currentLen = MathUtils.ease(Math.min(p * 2, 1), 'easeOutQuad') * vLen;

            const currentVx = currentLen * MathUtils.cos(currentAngle);
            const currentVy = currentLen * MathUtils.sin(currentAngle);

            renderer.drawVector(0, 0, currentVx, currentVy, {
                color: '#3b82f6',
                width: 3
            });

            if (p > 0.5) {
                const labelOpacity = MathUtils.ease((p - 0.5) / 0.5, 'easeOutQuad');
                drawMathBox('vec-v-label', '\\vec{v}', currentVx + 0.4, currentVy + 0.4, {
                    opacity: labelOpacity, fontSize: '1.3em', color: '#3b82f6',
                    bgColor: 'rgba(219, 234, 254, 0.9)', padding: '4px 8px'
                });
            }

            // Coordonnees affichees a GAUCHE avec LaTeX
            if (p > 0.7) {
                const infoOpacity = MathUtils.ease((p - 0.7) / 0.3, 'easeOutQuad');
                drawMathBox('coord-u-vec', `\\vec{u}(${ux}\\,;\\, ${uy})`, -9, 2.5, {
                    opacity: infoOpacity,
                    fontSize: '1.2em',
                    color: '#ef4444',
                    bgColor: 'rgba(254, 226, 226, 0.95)',
                    align: 'left'
                });
                drawMathBox('coord-v-vec', `\\vec{v}(${vx}\\,;\\, ${vy})`, -9, 1, {
                    opacity: infoOpacity,
                    fontSize: '1.2em',
                    color: '#3b82f6',
                    bgColor: 'rgba(219, 234, 254, 0.95)',
                    align: 'left'
                });
            }
        }

        // Stocker les vecteurs
        state.ux = ux; state.uy = uy;
        state.vx = vx; state.vy = vy;
    }
});


// === 04-angle.js ===

/**
 * Scene 4 : Angle entre les vecteurs
 * Arc vert montrant theta = 45 degres, formule geometrique
 * Utilise MathJax pour un rendu LaTeX parfait
 */

window.SCENE_REGISTRY.push({
    id: 'angle',
    title: 'Angle theta',
    duration: 10000,

    animate(localTime, progress, renderer, state) {
        const { contentProgress } = getProgressWithDelay(progress, 0.70);

        const ux = state.ux || 4;
        const uy = state.uy || 0;
        const vx = state.vx || 3;
        const vy = state.vy || 3;
        const angle = Math.PI / 4; // 45 degres

        // Vecteurs complets (toujours visibles)
        renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
        drawMathBox('vec-u-label', '\\vec{u}', ux + 0.5, 0.5, {
            fontSize: '1.3em', color: '#ef4444',
            bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
        });

        renderer.drawVector(0, 0, vx, vy, { color: '#3b82f6', width: 3 });
        drawMathBox('vec-v-label', '\\vec{v}', vx + 0.5, vy + 0.4, {
            fontSize: '1.3em', color: '#3b82f6',
            bgColor: 'rgba(219, 234, 254, 0.9)', padding: '4px 8px'
        });

        // Phase 1 : Arc de l'angle (0-40%)
        if (contentProgress < 0.4) {
            const p = contentProgress / 0.4;
            const arcProgress = MathUtils.ease(p, 'easeOutQuad');
            const arcAngle = angle * arcProgress;

            renderer.drawArc(0, 0, 1.2, 0, arcAngle, {
                strokeColor: '#10b981',
                fillColor: 'rgba(16, 185, 129, 0.1)',
                lineWidth: 3
            });

            // Label theta apparait apres l'arc
            if (p > 0.6) {
                const labelOpacity = MathUtils.ease((p - 0.6) / 0.4, 'easeOutQuad');
                drawMathBox('theta-label', '\\theta', 1.4, 0.55, {
                    opacity: labelOpacity,
                    fontSize: '1.4em',
                    color: '#10b981',
                    bgColor: 'rgba(209, 250, 229, 0.9)'
                });
            }
        }
        // Phase 2 : Affichage angle et formule (40-100%)
        else {
            const p = (contentProgress - 0.4) / 0.6;

            // Arc complet avec remplissage
            renderer.drawArc(0, 0, 1.2, 0, angle, {
                strokeColor: '#10b981',
                fillColor: 'rgba(16, 185, 129, 0.1)',
                lineWidth: 3
            });

            // Label theta (unique)
            drawMathBox('theta-label', '\\theta', 1.4, 0.55, {
                fontSize: '1.4em',
                color: '#10b981',
                bgColor: 'rgba(209, 250, 229, 0.9)'
            });

            // Valeur de l'angle a GAUCHE
            if (p > 0.15) {
                const angleOpacity = MathUtils.ease((p - 0.15) / 0.25, 'easeOutQuad');
                drawMathResult('angle-value', '\\theta = 45^\\circ', -9, 2.5, {
                    opacity: angleOpacity, align: 'left'
                });
            }

            // Formule geometrique a GAUCHE (sous l'angle)
            if (p > 0.45) {
                const formulaOpacity = MathUtils.ease((p - 0.45) / 0.35, 'easeOutQuad');
                drawMathBox('geom-formula', '\\vec{u} \\cdot \\vec{v} = \\|\\vec{u}\\| \\times \\|\\vec{v}\\| \\times \\cos(\\theta)', -9, 0.8, {
                    opacity: formulaOpacity, align: 'left',
                    fontSize: '1.25em',
                    color: '#1e3a8a',
                    bgColor: 'rgba(219, 234, 254, 0.95)'
                });
            }
        }

        state.angle = angle;
    }
});


// === 05-calcul-geometrique.js ===

/**
 * Scene 5 : Calcul avec la formule geometrique
 * Calcul etape par etape jusqu'a u.v = 12
 * Utilise MathJax pour un rendu LaTeX parfait
 */

window.SCENE_REGISTRY.push({
    id: 'calcul-geometrique',
    title: 'Calcul geometrique',
    duration: 14000,

    animate(localTime, progress, renderer, state) {
        const { contentProgress } = getProgressWithDelay(progress, 0.70);

        const ux = state.ux || 4;
        const uy = state.uy || 0;
        const vx = state.vx || 3;
        const vy = state.vy || 3;
        const angle = state.angle || Math.PI / 4;

        // Elements graphiques (au centre-droit)
        renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
        drawMathBox('vec-u-label', '\\vec{u}', ux + 0.5, 0.5, {
            fontSize: '1.3em', color: '#ef4444',
            bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
        });

        renderer.drawVector(0, 0, vx, vy, { color: '#3b82f6', width: 3 });
        drawMathBox('vec-v-label', '\\vec{v}', vx + 0.5, vy + 0.4, {
            fontSize: '1.3em', color: '#3b82f6',
            bgColor: 'rgba(219, 234, 254, 0.9)', padding: '4px 8px'
        });

        // Arc de l'angle
        renderer.drawArc(0, 0, 1.2, 0, angle, {
            strokeColor: '#10b981',
            fillColor: 'rgba(16, 185, 129, 0.1)',
            lineWidth: 2
        });
        drawMathBox('theta-label', '\\theta', 1.0, 0.55, {
            fontSize: '1.2em', color: '#10b981',
            bgColor: 'rgba(209, 250, 229, 0.9)', padding: '4px 8px'
        });

        // Calcul etape par etape a GAUCHE avec LaTeX
        const vNorm = Math.sqrt(vx * vx + vy * vy);
        const vNormFormatted = MathUtils.format(vNorm, 1);
        const productFormatted = MathUtils.format(4 * vNorm, 1);

        // Formules LaTeX
        const formulas = [
            { latex: '\\vec{u} \\cdot \\vec{v} = \\|\\vec{u}\\| \\times \\|\\vec{v}\\| \\times \\cos(\\theta)', y: 3.5, isFormula: true },
            { latex: `\\vec{u} \\cdot \\vec{v} = 4 \\times ${vNormFormatted} \\times \\cos(45^\\circ)`, y: 2, isFormula: false },
            { latex: `\\vec{u} \\cdot \\vec{v} = ${productFormatted} \\times \\frac{\\sqrt{2}}{2}`, y: 0.5, isFormula: false },
            { latex: '\\vec{u} \\cdot \\vec{v} = 12', y: -1, isResult: true }
        ];

        const lineDelay = 0.20;
        formulas.forEach((formula, i) => {
            const lineStart = i * lineDelay;
            if (contentProgress > lineStart) {
                const lineProgress = Math.min((contentProgress - lineStart) / lineDelay, 1);
                const opacity = MathUtils.ease(lineProgress, 'easeOutQuad');

                if (formula.isResult) {
                    drawMathResult(`calc-${i}`, formula.latex, -9, formula.y, {
                        opacity,
                        align: 'left'
                    });
                } else {
                    drawMathBox(`calc-${i}`, formula.latex, -9, formula.y, {
                        opacity,
                        fontSize: formula.isFormula ? '1.3em' : '1.2em',
                        color: formula.isFormula ? '#1e3a8a' : '#374151',
                        bgColor: formula.isFormula ? 'rgba(219, 234, 254, 0.95)' : 'rgba(255, 255, 255, 0.95)',
                        align: 'left'
                    });
                }
            }
        });

        state.dotProduct = 12;
    }
});


// === 06-projection.js ===

/**
 * Scene 6 : Projection orthogonale
 * Point H, vecteur OH, formule avec projection
 * Utilise MathJax pour un rendu LaTeX parfait
 */

window.SCENE_REGISTRY.push({
    id: 'projection',
    title: 'Projection orthogonale',
    duration: 14000,

    animate(localTime, progress, renderer, state) {
        const { contentProgress } = getProgressWithDelay(progress, 0.70);
        const ux = state.ux || 4;
        const uy = state.uy || 0;
        const vx = state.vx || 3;
        const vy = state.vy || 3;

        // Vecteurs
        renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
        drawMathBox('vec-u-label', '\\vec{u}', ux + 0.5, 0.5, {
            fontSize: '1.3em', color: '#ef4444',
            bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
        });

        renderer.drawVector(0, 0, vx, vy, { color: '#3b82f6', width: 3 });
        drawMathBox('vec-v-label', '\\vec{v}', vx + 0.5, vy + 0.4, {
            fontSize: '1.3em', color: '#3b82f6',
            bgColor: 'rgba(219, 234, 254, 0.9)', padding: '4px 8px'
        });

        // Calcul de la projection
        const dotProduct = ux * vx + uy * vy;
        const uNormSq = ux * ux + uy * uy;
        const projScalar = dotProduct / uNormSq;
        const hx = projScalar * ux;
        const hy = projScalar * uy;

        // Phase 1 : Point H apparait (10-40%)
        if (contentProgress > 0.1) {
            const p = Math.min((contentProgress - 0.1) / 0.3, 1);
            const pointProgress = MathUtils.ease(p, 'easeOutQuad');

            // Segment perpendiculaire [BH]
            renderer.drawSegment(vx, vy, hx, hy, {
                color: `rgba(155, 89, 182, ${pointProgress})`,
                width: 2, dashed: true
            });

            // Point H
            renderer.drawPoint(hx, hy, { radius: 6, color: '#9b59b6' });

            if (p > 0.5) {
                const labelOpacity = MathUtils.ease((p - 0.5) / 0.5, 'easeOutQuad');
                renderer.drawText('H', hx, hy - 0.5, {
                    color: `rgba(155, 89, 182, ${labelOpacity})`,
                    font: 'bold 18px Arial', align: 'center'
                });
            }
        }

        // Phase 2 : Vecteur OH (40-60%)
        if (contentProgress > 0.4) {
            const p = Math.min((contentProgress - 0.4) / 0.2, 1);
            const vectorProgress = MathUtils.ease(p, 'easeOutQuad');

            renderer.drawVector(0, 0, hx * vectorProgress, hy * vectorProgress, {
                color: '#9b59b6', width: 3
            });

            if (p > 0.5) {
                const labelOpacity = MathUtils.ease((p - 0.5) / 0.5, 'easeOutQuad');
                drawMathBox('oh-label', '\\overrightarrow{OH}', hx / 2, -0.6, {
                    opacity: labelOpacity,
                    fontSize: '1.1em',
                    color: '#9b59b6',
                    bgColor: 'rgba(243, 232, 255, 0.95)'
                });
            }
        }

        // Phase 3 : Formules a GAUCHE avec LaTeX (60-100%)
        if (contentProgress > 0.6) {
            const p = (contentProgress - 0.6) / 0.4;

            const formulas = [
                { latex: '\\vec{u} \\cdot \\vec{v} = \\|\\vec{u}\\| \\times OH', isFormula: true },
                { latex: '\\vec{u} \\cdot \\vec{v} = 4 \\times 3 = 12', isResult: true },
                { latex: 'OH = \\|\\vec{v}\\|\\cos(\\theta) = 3', isNote: true }
            ];

            const lineDelay = 0.25;
            formulas.forEach((formula, i) => {
                const lineStart = i * lineDelay;
                if (p > lineStart) {
                    const lineProgress = Math.min((p - lineStart) / lineDelay, 1);
                    const opacity = MathUtils.ease(lineProgress, 'easeOutQuad');

                    if (formula.isResult) {
                        drawMathResult(`proj-${i}`, formula.latex, -9, 3 - i * 1.5, {
                            opacity, align: 'left',
                            color: '#9b59b6',
                            bgColor: 'rgba(243, 232, 255, 0.98)',
                            borderColor: '#9b59b6'
                        });
                    } else {
                        drawMathBox(`proj-${i}`, formula.latex, -9, 3 - i * 1.5, {
                            opacity, align: 'left',
                            fontSize: formula.isNote ? '1.1em' : '1.25em',
                            color: formula.isNote ? '#6b7280' : '#1e3a8a',
                            bgColor: formula.isNote ? 'rgba(243, 244, 246, 0.95)' : 'rgba(255, 255, 255, 0.95)'
                        });
                    }
                }
            });
        }
    }
});


// === 07-analytique.js ===

/**
 * Scene 7 : Formule analytique
 * u.v = xu x xv + yu x yv, verification du resultat
 * Utilise MathJax pour un rendu LaTeX parfait
 */

window.SCENE_REGISTRY.push({
    id: 'analytique',
    title: 'Formule analytique',
    duration: 18000,

    animate(localTime, progress, renderer, state) {
        const { contentProgress } = getProgressWithDelay(progress, 0.70);
        const ux = state.ux || 4;
        const uy = state.uy || 0;
        const vx = state.vx || 3;
        const vy = state.vy || 3;

        // Vecteurs (au centre)
        renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
        drawMathBox('vec-u-label', '\\vec{u}', ux + 0.5, 0.5, {
            fontSize: '1.2em', color: '#ef4444',
            bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
        });
        renderer.drawVector(0, 0, vx, vy, { color: '#3b82f6', width: 3 });
        drawMathBox('vec-v-label', '\\vec{v}', vx + 0.5, vy + 0.4, {
            fontSize: '1.2em', color: '#3b82f6',
            bgColor: 'rgba(219, 234, 254, 0.9)', padding: '4px 8px'
        });

        // Phase 1 : Coordonnees apparaissent a cote des vecteurs
        if (contentProgress > 0) {
            const p = Math.min(contentProgress / 0.3, 1);
            const coordOpacity = MathUtils.ease(p, 'easeOutQuad');

            drawMathBox('coord-u', `\\vec{u}(${ux}; ${uy})`, ux + 0.5, 0.4, {
                opacity: coordOpacity,
                fontSize: '1.15em',
                color: '#ef4444',
                bgColor: 'rgba(254, 226, 226, 0.95)'
            });

            drawMathBox('coord-v', `\\vec{v}(${vx}; ${vy})`, vx + 0.5, vy + 0.4, {
                opacity: coordOpacity,
                fontSize: '1.15em',
                color: '#3b82f6',
                bgColor: 'rgba(219, 234, 254, 0.95)'
            });
        }

        // Phase 2 : Formule generale a GAUCHE (30-50%)
        if (contentProgress > 0.3) {
            const p = Math.min((contentProgress - 0.3) / 0.2, 1);
            const formulaOpacity = MathUtils.ease(p, 'easeOutQuad');

            drawMathBox('formula-ana', '\\vec{u} \\cdot \\vec{v} = x_u \\times x_v + y_u \\times y_v', -9, 3, {
                opacity: formulaOpacity, align: 'left',
                fontSize: '1.3em',
                color: '#1e3a8a',
                bgColor: 'rgba(219, 234, 254, 0.95)'
            });
        }

        // Phase 3 : Calcul etape par etape (50-100%)
        if (contentProgress > 0.5) {
            const p = (contentProgress - 0.5) / 0.5;

            const formulas = [
                { latex: `\\vec{u} \\cdot \\vec{v} = ${ux} \\times ${vx} + ${uy} \\times ${vy}`, isFormula: false },
                { latex: `\\vec{u} \\cdot \\vec{v} = ${ux * vx} + ${uy * vy}`, isFormula: false },
                { latex: '\\vec{u} \\cdot \\vec{v} = 12', isResult: true }
            ];

            const lineDelay = 0.25;
            formulas.forEach((formula, i) => {
                const lineStart = i * lineDelay;
                if (p > lineStart) {
                    const lineProgress = Math.min((p - lineStart) / lineDelay, 1);
                    const opacity = MathUtils.ease(lineProgress, 'easeOutQuad');

                    if (formula.isResult) {
                        drawMathResult(`ana-${i}`, formula.latex, -9, 2 - i * 1.5, {
                            opacity, align: 'left'
                        });
                    } else {
                        drawMathBox(`ana-${i}`, formula.latex, -9, 2 - i * 1.5, {
                            opacity, align: 'left',
                            fontSize: '1.2em',
                            color: '#374151',
                            bgColor: 'rgba(255, 255, 255, 0.95)'
                        });
                    }
                }
            });

            // Message "Meme resultat !" en BAS centre
            if (p > 0.8) {
                const msgOpacity = MathUtils.ease((p - 0.8) / 0.2, 'easeOutQuad');
                drawMathBox('same-result', '\\checkmark \\text{ Meme resultat !}', 0, -3.5, {
                    opacity: msgOpacity,
                    fontSize: '1.4em',
                    color: '#059669',
                    bgColor: 'rgba(209, 250, 229, 0.98)',
                    borderColor: '#10b981',
                    borderWidth: 2
                });
            }
        }
    }
});


// === 08-orthogonalite.js ===

/**
 * Scene 8 : Orthogonalite
 * Vecteurs u(3,2) et v(-2,3), u.v = 0
 * Utilise MathJax pour un rendu LaTeX parfait
 */

window.SCENE_REGISTRY.push({
    id: 'orthogonalite',
    title: 'Orthogonalite',
    duration: 22000,

    animate(localTime, progress, renderer, state) {
        const { contentProgress } = getProgressWithDelay(progress, 0.70);
        // Nouveaux vecteurs orthogonaux
        const ux = 3, uy = 2;
        const vx = -2, vy = 3;

        // Phase 1 : Transition - nouveaux vecteurs (0-25%)
        if (contentProgress < 0.25) {
            const p = contentProgress / 0.25;
            const len = MathUtils.ease(p, 'easeOutQuad');

            renderer.drawVector(0, 0, ux * len, uy * len, { color: '#ef4444', width: 3 });

            if (p > 0.3) {
                const vProgress = MathUtils.ease((p - 0.3) / 0.7, 'easeOutQuad');
                renderer.drawVector(0, 0, vx * vProgress, vy * vProgress, { color: '#3b82f6', width: 3 });
            }
        }
        // Phase 2 : Calcul du produit scalaire (25-60%)
        else if (contentProgress < 0.6) {
            const p = (contentProgress - 0.25) / 0.35;

            // Vecteurs complets
            renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
            drawMathBox('orth-coord-u', `\\vec{u}(${ux}\\,;\\,${uy})`, ux + 0.5, uy + 0.4, {
                fontSize: '1.1em',
                color: '#ef4444',
                bgColor: 'rgba(254, 226, 226, 0.95)'
            });

            renderer.drawVector(0, 0, vx, vy, { color: '#3b82f6', width: 3 });
            drawMathBox('orth-coord-v', `\\vec{v}(${vx}\\,;\\,${vy})`, vx - 1.5, vy + 0.4, {
                fontSize: '1.1em',
                color: '#3b82f6',
                bgColor: 'rgba(219, 234, 254, 0.95)'
            });

            // Calcul a GAUCHE avec LaTeX
            const formulas = [
                { latex: `\\vec{u} \\cdot \\vec{v} = ${ux} \\times (${vx}) + ${uy} \\times ${vy}`, isFormula: false },
                { latex: `\\vec{u} \\cdot \\vec{v} = ${ux * vx} + ${uy * vy}`, isFormula: false },
                { latex: '\\vec{u} \\cdot \\vec{v} = 0', isResult: true }
            ];

            const lineDelay = 0.25;
            formulas.forEach((formula, i) => {
                const lineStart = i * lineDelay;
                if (p > lineStart) {
                    const lineProgress = Math.min((p - lineStart) / lineDelay, 1);
                    const opacity = MathUtils.ease(lineProgress, 'easeOutQuad');

                    if (formula.isResult) {
                        drawMathResult(`orth-calc-${i}`, formula.latex, -9, 3.5 - i * 1.5, {
                            opacity, align: 'left',
                            color: '#3b82f6'
                        });
                    } else {
                        drawMathBox(`orth-calc-${i}`, formula.latex, -9, 3.5 - i * 1.5, {
                            opacity, align: 'left',
                            fontSize: '1.2em',
                            color: '#374151',
                            bgColor: 'rgba(255, 255, 255, 0.95)'
                        });
                    }
                }
            });
        }
        // Phase 3 : Angle droit et conclusion (60-100%)
        else {
            const p = (contentProgress - 0.6) / 0.4;

            // Vecteurs
            renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
            drawMathBox('vec-u-label-3', '\\vec{u}', ux + 0.4, uy + 0.4, {
                fontSize: '1.2em', color: '#ef4444',
                bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
            });
            renderer.drawVector(0, 0, vx, vy, { color: '#3b82f6', width: 3 });
            drawMathBox('vec-v-label-3', '\\vec{v}', vx - 0.8, vy + 0.4, {
                fontSize: '1.2em', color: '#3b82f6',
                bgColor: 'rgba(219, 234, 254, 0.9)', padding: '4px 8px'
            });

            // Carre de l'angle droit
            if (p > 0.1) {
                const squareSize = 0.5;
                const squareOpacity = MathUtils.ease((p - 0.1) / 0.2, 'easeOutQuad');

                const uNorm = Math.sqrt(ux * ux + uy * uy);
                const vNorm = Math.sqrt(vx * vx + vy * vy);

                const ux_n = ux / uNorm * squareSize;
                const uy_n = uy / uNorm * squareSize;
                const vx_n = vx / vNorm * squareSize;
                const vy_n = vy / vNorm * squareSize;

                // Dessiner le carre de l'angle droit
                renderer.drawSegment(ux_n, uy_n, ux_n + vx_n, uy_n + vy_n, {
                    color: `rgba(16, 185, 129, ${squareOpacity})`, width: 2
                });
                renderer.drawSegment(vx_n, vy_n, ux_n + vx_n, uy_n + vy_n, {
                    color: `rgba(16, 185, 129, ${squareOpacity})`, width: 2
                });
            }

            // Message "ORTHOGONAUX" en BAS avec LaTeX
            if (p > 0.3) {
                const msgOpacity = MathUtils.ease((p - 0.3) / 0.2, 'easeOutQuad');
                drawMathBox('orth-msg', '\\text{Vecteurs ORTHOGONAUX}', 0, -3, {
                    opacity: msgOpacity,
                    fontSize: '1.5em',
                    color: '#3b82f6',
                    bgColor: 'rgba(219, 234, 254, 0.98)',
                    borderColor: '#3b82f6',
                    borderWidth: 2
                });
            }

            // Propriete encadree
            if (p > 0.5) {
                const boxOpacity = MathUtils.ease((p - 0.5) / 0.3, 'easeOutQuad');
                drawMathResult('orth-property', '\\vec{u} \\perp \\vec{v} \\Leftrightarrow \\vec{u} \\cdot \\vec{v} = 0', 0, -4.5, {
                    opacity: boxOpacity,
                    fontSize: '1.4em',
                    color: '#d97706',
                    bgColor: 'rgba(254, 243, 199, 0.98)',
                    borderColor: '#f59e0b'
                });
            }
        }
    }
});


// === 09-signe.js ===

/**
 * Scene 9 : Signe du produit scalaire
 * v tourne autour de u, zones colorees selon le signe
 * IMPORTANT: LaTeX statique + valeurs dynamiques separees pour eviter recompilation
 */

window.SCENE_REGISTRY.push({
    id: 'signe',
    title: 'Signe du produit scalaire',
    duration: 20000,

    animate(localTime, progress, renderer, state) {
        const { contentProgress } = getProgressWithDelay(progress, 0.70);
        const ux = 3, uy = 0;

        // Zones de fond colorees (toujours visibles apres 10%)
        if (contentProgress > 0.05) {
            const zoneOpacity = Math.min((contentProgress - 0.05) / 0.1, 0.15);

            // Zone verte (angle aigu) : -90 a +90 degres
            for (let a = -Math.PI / 2; a < Math.PI / 2; a += 0.05) {
                const r = 5.5;
                renderer.drawSegment(0, 0, r * MathUtils.cos(a), r * MathUtils.sin(a), {
                    color: `rgba(16, 185, 129, ${zoneOpacity})`, width: 15
                });
            }

            // Zone orange (angle obtus) : +90 a +270 degres
            for (let a = Math.PI / 2; a < 3 * Math.PI / 2; a += 0.05) {
                const r = 5.5;
                renderer.drawSegment(0, 0, r * MathUtils.cos(a), r * MathUtils.sin(a), {
                    color: `rgba(249, 115, 22, ${zoneOpacity})`, width: 15
                });
            }
        }

        // Vecteur u fixe
        renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
        drawMathBox('vec-u-label', '\\vec{u}', ux + 0.4, 0.5, {
            fontSize: '1.2em', color: '#ef4444',
            bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
        });

        // Vecteur v tourne
        const angle = contentProgress * 2 * Math.PI;
        const vLen = 2.5;
        const vx = vLen * MathUtils.cos(angle);
        const vy = vLen * MathUtils.sin(angle);

        renderer.drawVector(0, 0, vx, vy, { color: '#3b82f6', width: 3 });
        drawMathBox('vec-v-label', '\\vec{v}', vx + 0.4, vy + 0.4, {
            fontSize: '1.2em', color: '#3b82f6',
            bgColor: 'rgba(219, 234, 254, 0.9)', padding: '4px 8px'
        });

        // Calculs
        const dotProduct = ux * vx + uy * vy;
        let angleDeg = (angle * 180 / Math.PI) % 360;
        if (angleDeg > 180) angleDeg = angleDeg - 360;
        angleDeg = Math.abs(angleDeg);

        // Determiner couleur et message
        let color, messageText, bgColor;
        if (Math.abs(dotProduct) < 0.5) {
            color = '#3b82f6';
            messageText = 'Angle droit (θ = 90°)';
            bgColor = 'rgba(219, 234, 254, 0.95)';
        } else if (dotProduct > 0) {
            color = '#10b981';
            messageText = 'Angle aigu (θ < 90°)';
            bgColor = 'rgba(209, 250, 229, 0.95)';
        } else {
            color = '#f97316';
            messageText = 'Angle obtus (θ > 90°)';
            bgColor = 'rgba(254, 243, 199, 0.95)';
        }

        // === DISPOSITION A GAUCHE (x = -9) ===
        // IMPORTANT: LaTeX STATIQUE uniquement (pas de recompilation)

        // Label statique "Produit scalaire :"
        drawMathBox('signe-label', '\\vec{u} \\cdot \\vec{v} =', -9, 3.5, {
            fontSize: '1.4em', color: '#1e3a8a', align: 'left',
            bgColor: 'rgba(255, 255, 255, 0.95)'
        });

        // Valeur DYNAMIQUE en drawTextBox (pas MathJax) - a cote du label
        drawTextBox(renderer, MathUtils.format(dotProduct, 1), -5.5, 3.5, {
            font: 'bold 26px Arial',
            color: color,
            bgColor: bgColor,
            borderColor: color,
            borderWidth: 2,
            padding: 10
        });

        // Angle theta (valeur dynamique en canvas)
        drawTextBox(renderer, `θ ≈ ${MathUtils.format(angleDeg, 0)}°`, -9, 1.5, {
            font: '20px Arial',
            color: '#64748b',
            bgColor: 'rgba(248, 250, 252, 0.95)',
            align: 'left'
        });

        // Message interpretation (dynamique en canvas)
        drawTextBox(renderer, messageText, -9, -0.5, {
            font: 'bold 18px Arial',
            color: color,
            bgColor: bgColor,
            align: 'left'
        });

        // Legende en BAS
        if (contentProgress > 0.3) {
            const legendOpacity = Math.min((contentProgress - 0.3) / 0.1, 1);
            drawTextBox(renderer, 'Vert = aigu | Orange = obtus', 0, -4.5, {
                font: '16px Arial', color: '#64748b', opacity: legendOpacity
            });
        }
    }
});


// === 10-recap.js ===

/**
 * Scene 10 : Recapitulatif
 * Les 3 formules encadrees - SANS axes ni grille
 * Utilise MathJax pour un rendu LaTeX parfait
 */

window.SCENE_REGISTRY.push({
    id: 'recap',
    title: 'Recapitulatif',
    duration: 18000,
    hideGrid: true,
    hideAxes: true,

    animate(localTime, progress, renderer, state) {
        const { contentProgress } = getProgressWithDelay(progress, 0.70);

        // Fond legerement colore
        const ctx = renderer.ctx;
        const gradient = ctx.createLinearGradient(0, 0, 0, renderer.height);
        gradient.addColorStop(0, 'rgba(248, 250, 252, 1)');
        gradient.addColorStop(1, 'rgba(241, 245, 249, 1)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, renderer.width, renderer.height);

        // Titre
        if (contentProgress > 0) {
            const titleOpacity = MathUtils.ease(Math.min(contentProgress / 0.12, 1), 'easeOutQuad');

            drawMathBox('recap-title', '\\textbf{A RETENIR}', 0, 4.2, {
                opacity: titleOpacity,
                fontSize: '2em',
                color: '#1e3a8a',
                bgColor: 'rgba(219, 234, 254, 0.98)',
                borderColor: '#3b82f6',
                borderWidth: 2
            });
        }

        const formulas = [
            {
                title: 'Formule geometrique',
                latex: '\\vec{u} \\cdot \\vec{v} = \\|\\vec{u}\\| \\times \\|\\vec{v}\\| \\times \\cos(\\theta)',
                y: 2.2,
                color: '#059669',
                bgColor: 'rgba(209, 250, 229, 0.98)',
                borderColor: '#10b981'
            },
            {
                title: 'Formule analytique',
                latex: '\\vec{u} \\cdot \\vec{v} = x_u \\times x_v + y_u \\times y_v',
                y: 0,
                color: '#1d4ed8',
                bgColor: 'rgba(219, 234, 254, 0.98)',
                borderColor: '#3b82f6'
            },
            {
                title: 'Critere d\'orthogonalite',
                latex: '\\vec{u} \\perp \\vec{v} \\Leftrightarrow \\vec{u} \\cdot \\vec{v} = 0',
                y: -2.2,
                color: '#d97706',
                bgColor: 'rgba(254, 243, 199, 0.98)',
                borderColor: '#f59e0b'
            }
        ];

        formulas.forEach((item, i) => {
            const startTime = 0.12 + i * 0.18;
            if (contentProgress > startTime) {
                const p = Math.min((contentProgress - startTime) / 0.15, 1);
                const opacity = MathUtils.ease(p, 'easeOutCubic');
                const slideOffset = (1 - MathUtils.ease(p, 'easeOutBack')) * 0.8;

                // Titre de la formule
                renderer.drawText(item.title, 0, item.y + 0.75 + slideOffset, {
                    font: 'bold 20px Arial',
                    color: `rgba(100, 116, 139, ${opacity})`,
                    align: 'center'
                });

                // Formule encadree avec LaTeX
                drawMathResult(`recap-formula-${i}`, item.latex, 0, item.y - 0.25 + slideOffset, {
                    opacity,
                    fontSize: '1.5em',
                    color: item.color,
                    bgColor: item.bgColor,
                    borderColor: item.borderColor
                });
            }
        });

        // Message de fin avec delai
        if (contentProgress > 0.75) {
            const endOpacity = MathUtils.ease((contentProgress - 0.75) / 0.25, 'easeOutQuad');
            renderer.drawText('Fin de l\'animation', 0, -4.5, {
                font: '20px Arial',
                color: `rgba(100, 116, 139, ${endOpacity})`,
                align: 'center'
            });
        }
    }
});


// === 11-exemple-avance.js ===

/**
 * Scene 11 : Exemple avance
 * Vecteurs quelconques u(2,3) et v(4,-1)
 * On applique les 3 methodes et on verifie la coherence
 */

window.SCENE_REGISTRY.push({
    id: 'exemple-avance',
    title: 'Exemple avance',
    duration: 38000,

    animate(localTime, progress, renderer, state) {
        const { contentProgress } = getProgressWithDelay(progress, 0.70);

        // Vecteurs quelconques (pas sur les axes)
        const ux = 2, uy = 3;
        const vx = 4, vy = -1;

        // Calculs
        const uNorm = Math.sqrt(ux * ux + uy * uy);
        const vNorm = Math.sqrt(vx * vx + vy * vy);
        const dotProduct = ux * vx + uy * vy;
        const cosTheta = dotProduct / (uNorm * vNorm);
        const theta = Math.acos(cosTheta);
        const thetaDeg = theta * 180 / Math.PI;

        // Phase 1 : Presentation des vecteurs (0-15%)
        if (contentProgress < 0.15) {
            const p = contentProgress / 0.15;
            const len = MathUtils.ease(p, 'easeOutQuad');

            renderer.drawVector(0, 0, ux * len, uy * len, { color: '#ef4444', width: 3 });
            if (p > 0.3) {
                drawMathBox('vec-u', '\\vec{u}', ux * len + 0.4, uy * len + 0.4, {
                    opacity: (p - 0.3) / 0.7, fontSize: '1.2em', color: '#ef4444',
                    bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
                });
            }

            if (p > 0.5) {
                const vProgress = (p - 0.5) / 0.5;
                renderer.drawVector(0, 0, vx * vProgress, vy * vProgress, { color: '#3b82f6', width: 3 });
                if (vProgress > 0.6) {
                    drawMathBox('vec-v', '\\vec{v}', vx * vProgress + 0.4, vy * vProgress - 0.4, {
                        opacity: (vProgress - 0.6) / 0.4, fontSize: '1.2em', color: '#3b82f6',
                        bgColor: 'rgba(219, 234, 254, 0.9)', padding: '4px 8px'
                    });
                }
            }

            // Coordonnees a gauche
            if (p > 0.7) {
                const coordOpacity = (p - 0.7) / 0.3;
                drawMathBox('coord-u', `\\vec{u}(${ux}\\,;\\,${uy})`, -9, 3.5, {
                    opacity: coordOpacity, fontSize: '1.2em', color: '#ef4444',
                    bgColor: 'rgba(254, 226, 226, 0.95)', align: 'left'
                });
                drawMathBox('coord-v', `\\vec{v}(${vx}\\,;\\,${vy})`, -9, 2, {
                    opacity: coordOpacity, fontSize: '1.2em', color: '#3b82f6',
                    bgColor: 'rgba(219, 234, 254, 0.95)', align: 'left'
                });
            }
        }
        // Phase 2 : Methode analytique (15-40%)
        else if (contentProgress < 0.4) {
            const p = (contentProgress - 0.15) / 0.25;

            // Vecteurs complets
            renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
            drawMathBox('vec-u', '\\vec{u}', ux + 0.4, uy + 0.4, {
                fontSize: '1.2em', color: '#ef4444',
                bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
            });
            renderer.drawVector(0, 0, vx, vy, { color: '#3b82f6', width: 3 });
            drawMathBox('vec-v', '\\vec{v}', vx + 0.4, vy - 0.4, {
                fontSize: '1.2em', color: '#3b82f6',
                bgColor: 'rgba(219, 234, 254, 0.9)', padding: '4px 8px'
            });

            // Titre methode
            if (p > 0) {
                const titleOpacity = Math.min(p / 0.15, 1);
                drawMathBox('method-title', '\\textbf{Methode analytique}', -9, 4, {
                    opacity: titleOpacity, fontSize: '1.3em', color: '#1d4ed8',
                    bgColor: 'rgba(219, 234, 254, 0.98)', align: 'left',
                    borderColor: '#3b82f6', borderWidth: 1
                });
            }

            // Calcul etape par etape
            const formulas = [
                `\\vec{u} \\cdot \\vec{v} = x_u \\times x_v + y_u \\times y_v`,
                `\\vec{u} \\cdot \\vec{v} = ${ux} \\times ${vx} + ${uy} \\times (${vy})`,
                `\\vec{u} \\cdot \\vec{v} = ${ux * vx} + (${uy * vy})`,
                `\\vec{u} \\cdot \\vec{v} = ${dotProduct}`
            ];

            const lineDelay = 0.2;
            formulas.forEach((latex, i) => {
                const lineStart = 0.1 + i * lineDelay;
                if (p > lineStart) {
                    const lineProgress = Math.min((p - lineStart) / lineDelay, 1);
                    const opacity = MathUtils.ease(lineProgress, 'easeOutQuad');
                    const isResult = i === formulas.length - 1;

                    if (isResult) {
                        drawMathResult(`ana-${i}`, latex, -9, 2.5 - i * 1.5, {
                            opacity, align: 'left', color: '#1d4ed8'
                        });
                    } else {
                        drawMathBox(`ana-${i}`, latex, -9, 2.5 - i * 1.5, {
                            opacity, align: 'left', fontSize: '1.15em',
                            color: i === 0 ? '#1e3a8a' : '#374151',
                            bgColor: 'rgba(255, 255, 255, 0.95)'
                        });
                    }
                }
            });
        }
        // Phase 3 : Methode geometrique (40-70%)
        else if (contentProgress < 0.7) {
            const p = (contentProgress - 0.4) / 0.3;

            // Vecteurs
            renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
            drawMathBox('vec-u', '\\vec{u}', ux + 0.4, uy + 0.4, {
                fontSize: '1.2em', color: '#ef4444',
                bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
            });
            renderer.drawVector(0, 0, vx, vy, { color: '#3b82f6', width: 3 });
            drawMathBox('vec-v', '\\vec{v}', vx + 0.4, vy - 0.4, {
                fontSize: '1.2em', color: '#3b82f6',
                bgColor: 'rgba(219, 234, 254, 0.9)', padding: '4px 8px'
            });

            // Arc de l'angle
            const angleU = Math.atan2(uy, ux);
            const angleV = Math.atan2(vy, vx);
            renderer.drawArc(0, 0, 1.0, Math.min(angleU, angleV), Math.max(angleU, angleV), {
                strokeColor: '#10b981', fillColor: 'rgba(16, 185, 129, 0.15)', lineWidth: 2
            });
            drawMathBox('theta-label', '\\theta', 1.3, 0.8, {
                fontSize: '1.1em', color: '#10b981', bgColor: 'rgba(209, 250, 229, 0.9)'
            });

            // Titre methode
            if (p > 0) {
                const titleOpacity = Math.min(p / 0.15, 1);
                drawMathBox('method-title-2', '\\textbf{Methode geometrique}', -9, 4, {
                    opacity: titleOpacity, fontSize: '1.3em', color: '#059669',
                    bgColor: 'rgba(209, 250, 229, 0.98)', align: 'left',
                    borderColor: '#10b981', borderWidth: 1
                });
            }

            // Calculs
            const formulas = [
                `\\|\\vec{u}\\| = \\sqrt{${ux}^2 + ${uy}^2} = \\sqrt{${ux*ux + uy*uy}} \\approx ${MathUtils.format(uNorm, 2)}`,
                `\\|\\vec{v}\\| = \\sqrt{${vx}^2 + (${vy})^2} = \\sqrt{${vx*vx + vy*vy}} \\approx ${MathUtils.format(vNorm, 2)}`,
                `\\theta \\approx ${MathUtils.format(thetaDeg, 1)}^\\circ`,
                `\\vec{u} \\cdot \\vec{v} = ${MathUtils.format(uNorm, 2)} \\times ${MathUtils.format(vNorm, 2)} \\times \\cos(${MathUtils.format(thetaDeg, 0)}^\\circ)`,
                `\\vec{u} \\cdot \\vec{v} = ${dotProduct}`
            ];

            const lineDelay = 0.15;
            formulas.forEach((latex, i) => {
                const lineStart = 0.1 + i * lineDelay;
                if (p > lineStart) {
                    const lineProgress = Math.min((p - lineStart) / lineDelay, 1);
                    const opacity = MathUtils.ease(lineProgress, 'easeOutQuad');
                    const isResult = i === formulas.length - 1;

                    if (isResult) {
                        drawMathResult(`geom-${i}`, latex, -9, 2.5 - i * 1.3, {
                            opacity, align: 'left', color: '#059669'
                        });
                    } else {
                        drawMathBox(`geom-${i}`, latex, -9, 2.5 - i * 1.3, {
                            opacity, align: 'left', fontSize: '1.1em',
                            color: '#374151', bgColor: 'rgba(255, 255, 255, 0.95)'
                        });
                    }
                }
            });
        }
        // Phase 4 : Conclusion (70-100%)
        else {
            const p = (contentProgress - 0.7) / 0.3;

            // Vecteurs
            renderer.drawVector(0, 0, ux, uy, { color: '#ef4444', width: 3 });
            drawMathBox('vec-u', '\\vec{u}', ux + 0.4, uy + 0.4, {
                fontSize: '1.2em', color: '#ef4444',
                bgColor: 'rgba(254, 226, 226, 0.9)', padding: '4px 8px'
            });
            renderer.drawVector(0, 0, vx, vy, { color: '#3b82f6', width: 3 });
            drawMathBox('vec-v', '\\vec{v}', vx + 0.4, vy - 0.4, {
                fontSize: '1.2em', color: '#3b82f6',
                bgColor: 'rgba(219, 234, 254, 0.9)', padding: '4px 8px'
            });

            // Arc
            const angleU = Math.atan2(uy, ux);
            const angleV = Math.atan2(vy, vx);
            renderer.drawArc(0, 0, 1.0, Math.min(angleU, angleV), Math.max(angleU, angleV), {
                strokeColor: '#10b981', fillColor: 'rgba(16, 185, 129, 0.15)', lineWidth: 2
            });

            // Conclusion
            if (p > 0.1) {
                const opacity = MathUtils.ease((p - 0.1) / 0.3, 'easeOutQuad');
                drawMathBox('conclusion-title', '\\checkmark \\textbf{ Verification}', -9, 3.5, {
                    opacity, fontSize: '1.3em', color: '#059669',
                    bgColor: 'rgba(209, 250, 229, 0.98)', align: 'left',
                    borderColor: '#10b981', borderWidth: 2
                });
            }

            if (p > 0.3) {
                const opacity = MathUtils.ease((p - 0.3) / 0.3, 'easeOutQuad');
                drawMathBox('conclusion-1', `\\text{Analytique : } \\vec{u} \\cdot \\vec{v} = ${dotProduct}`, -9, 2, {
                    opacity, fontSize: '1.2em', color: '#1d4ed8',
                    bgColor: 'rgba(219, 234, 254, 0.95)', align: 'left'
                });
            }

            if (p > 0.5) {
                const opacity = MathUtils.ease((p - 0.5) / 0.3, 'easeOutQuad');
                drawMathBox('conclusion-2', `\\text{Geometrique : } \\vec{u} \\cdot \\vec{v} \\approx ${dotProduct}`, -9, 0.5, {
                    opacity, fontSize: '1.2em', color: '#059669',
                    bgColor: 'rgba(209, 250, 229, 0.95)', align: 'left'
                });
            }

            if (p > 0.7) {
                const opacity = MathUtils.ease((p - 0.7) / 0.3, 'easeOutQuad');
                drawMathResult('same-result', '\\text{Meme resultat !}', 0, -3.5, {
                    opacity, fontSize: '1.5em', color: '#059669'
                });
            }
        }
    }
});


// === 12-qcm-methodes.js ===

/**
 * Scene 12 : QCM - Choisir la methode adaptee
 * 3 enonces a associer a la bonne methode
 * Pause pour reflexion puis correction avec fleches
 */

window.SCENE_REGISTRY.push({
    id: 'qcm-methodes',
    title: 'Quelle methode choisir ?',
    duration: 35000,
    hideGrid: true,
    hideAxes: true,

    animate(localTime, progress, renderer, state) {
        const { contentProgress } = getProgressWithDelay(progress, 0.70);

        // Fond degrade
        const ctx = renderer.ctx;
        const gradient = ctx.createLinearGradient(0, 0, 0, renderer.height);
        gradient.addColorStop(0, 'rgba(248, 250, 252, 1)');
        gradient.addColorStop(1, 'rgba(241, 245, 249, 1)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, renderer.width, renderer.height);

        // Enonces (a gauche)
        const enonces = [
            {
                id: 'E1',
                text: 'On connait les coordonnees',
                subtext: 'des deux vecteurs',
                y: 2.5,
                solution: 'analytique',
                color: '#ef4444'
            },
            {
                id: 'E2',
                text: 'On connait les normes et',
                subtext: 'l\'angle entre les vecteurs',
                y: 0,
                solution: 'geometrique',
                color: '#3b82f6'
            },
            {
                id: 'E3',
                text: 'On veut savoir si deux',
                subtext: 'vecteurs sont orthogonaux',
                y: -2.5,
                solution: 'orthogonalite',
                color: '#10b981'
            }
        ];

        // Methodes (a droite)
        const methodes = [
            {
                id: 'M1',
                name: 'Geometrique',
                latex: '\\|\\vec{u}\\| \\times \\|\\vec{v}\\| \\times \\cos\\theta',
                y: 2.5,
                color: '#059669',
                bgColor: 'rgba(209, 250, 229, 0.98)'
            },
            {
                id: 'M2',
                name: 'Analytique',
                latex: 'x_u \\times x_v + y_u \\times y_v',
                y: 0,
                color: '#1d4ed8',
                bgColor: 'rgba(219, 234, 254, 0.98)'
            },
            {
                id: 'M3',
                name: 'Test orthogonalite',
                latex: '\\vec{u} \\cdot \\vec{v} = 0 \\,?',
                y: -2.5,
                color: '#d97706',
                bgColor: 'rgba(254, 243, 199, 0.98)'
            }
        ];

        // Phase 1 : Titre (0-8%)
        if (contentProgress > 0) {
            const titleOpacity = MathUtils.ease(Math.min(contentProgress / 0.08, 1), 'easeOutQuad');
            drawMathBox('qcm-title', '\\textbf{Quelle methode utiliser ?}', 0, 4.5, {
                opacity: titleOpacity,
                fontSize: '1.8em',
                color: '#1e3a8a',
                bgColor: 'rgba(219, 234, 254, 0.98)',
                borderColor: '#3b82f6',
                borderWidth: 2
            });
        }

        // Phase 2 : Apparition des enonces (8-25%)
        enonces.forEach((enonce, i) => {
            const startTime = 0.08 + i * 0.06;
            if (contentProgress > startTime) {
                const p = Math.min((contentProgress - startTime) / 0.08, 1);
                const opacity = MathUtils.ease(p, 'easeOutCubic');
                const slideX = (1 - MathUtils.ease(p, 'easeOutBack')) * 1.5;

                // Numero
                renderer.drawText(enonce.id, -10 - slideX, enonce.y + 0.3, {
                    font: 'bold 24px Arial',
                    color: `rgba(${enonce.color === '#ef4444' ? '239,68,68' : enonce.color === '#3b82f6' ? '59,130,246' : '16,185,129'}, ${opacity})`,
                    align: 'center'
                });

                // Texte
                drawTextBox(renderer, enonce.text, -7 - slideX, enonce.y + 0.3, {
                    font: '18px Arial', color: '#374151', opacity,
                    bgColor: 'rgba(255, 255, 255, 0.95)', align: 'left'
                });
                drawTextBox(renderer, enonce.subtext, -7 - slideX, enonce.y - 0.4, {
                    font: '18px Arial', color: '#374151', opacity,
                    bgColor: 'rgba(255, 255, 255, 0.95)', align: 'left'
                });
            }
        });

        // Phase 3 : Apparition des methodes (25-40%)
        methodes.forEach((methode, i) => {
            const startTime = 0.25 + i * 0.05;
            if (contentProgress > startTime) {
                const p = Math.min((contentProgress - startTime) / 0.08, 1);
                const opacity = MathUtils.ease(p, 'easeOutCubic');
                const slideX = (1 - MathUtils.ease(p, 'easeOutBack')) * 1.5;

                // Nom de la methode
                renderer.drawText(methode.name, 6 + slideX, methode.y + 0.6, {
                    font: 'bold 16px Arial',
                    color: `rgba(100, 116, 139, ${opacity})`,
                    align: 'center'
                });

                // Formule
                drawMathBox(`methode-${i}`, methode.latex, 6 + slideX, methode.y - 0.2, {
                    opacity,
                    fontSize: '1.2em',
                    color: methode.color,
                    bgColor: methode.bgColor,
                    borderColor: methode.color,
                    borderWidth: 1
                });
            }
        });

        // Phase 4 : Pause reflexion (40-55%)
        if (contentProgress > 0.40 && contentProgress < 0.55) {
            const p = (contentProgress - 0.40) / 0.15;
            const pulseOpacity = 0.6 + 0.4 * Math.sin(p * Math.PI * 4);

            renderer.drawText('Associez chaque enonce a la methode adaptee...', 0, -4, {
                font: 'italic 20px Arial',
                color: `rgba(100, 116, 139, ${pulseOpacity})`,
                align: 'center'
            });
        }

        // Phase 5 : Correction avec fleches (55-100%)
        if (contentProgress > 0.55) {
            const correctionProgress = (contentProgress - 0.55) / 0.45;

            // Mapping : E1 -> M2 (analytique), E2 -> M1 (geometrique), E3 -> M3 (orthogonalite)
            const associations = [
                { from: enonces[0], to: methodes[1], delay: 0, color: '#1d4ed8' },      // E1 -> Analytique
                { from: enonces[1], to: methodes[0], delay: 0.25, color: '#059669' },   // E2 -> Geometrique
                { from: enonces[2], to: methodes[2], delay: 0.50, color: '#d97706' }    // E3 -> Orthogonalite
            ];

            associations.forEach((assoc, i) => {
                if (correctionProgress > assoc.delay) {
                    const p = Math.min((correctionProgress - assoc.delay) / 0.2, 1);
                    const arrowProgress = MathUtils.ease(p, 'easeOutCubic');
                    const opacity = arrowProgress;

                    // Points de depart et arrivee (ajustes pour eviter le texte)
                    const x1 = -2.5;  // Apres les enonces
                    const y1 = assoc.from.y;
                    const x2 = 3.5;   // Avant les methodes
                    const y2 = assoc.to.y;

                    // Dessiner la fleche progressivement
                    const currentX = x1 + (x2 - x1) * arrowProgress;
                    const currentY = y1 + (y2 - y1) * arrowProgress;

                    // Ligne courbe (bezier simplifie en segments)
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.strokeStyle = assoc.color;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);

                    const startPixel = renderer.toPixel(x1, y1);
                    const endPixel = renderer.toPixel(currentX, currentY);
                    const midY = (y1 + y2) / 2;
                    // Courbure moderee vers le haut
                    const curveOffset = Math.abs(y2 - y1) > 1 ? 0.8 : 0.3;
                    const controlPixel = renderer.toPixel((x1 + x2) / 2, midY + curveOffset);

                    ctx.beginPath();
                    ctx.moveTo(startPixel.x, startPixel.y);
                    ctx.quadraticCurveTo(controlPixel.x, controlPixel.y, endPixel.x, endPixel.y);
                    ctx.stroke();

                    // Pointe de fleche si complete
                    if (arrowProgress > 0.9) {
                        const angle = Math.atan2(y2 - midY - curveOffset, x2 - (x1 + x2) / 2);
                        const arrowSize = 12;

                        ctx.beginPath();
                        ctx.moveTo(endPixel.x, endPixel.y);
                        ctx.lineTo(
                            endPixel.x - arrowSize * Math.cos(angle - Math.PI / 6),
                            endPixel.y + arrowSize * Math.sin(angle - Math.PI / 6)
                        );
                        ctx.moveTo(endPixel.x, endPixel.y);
                        ctx.lineTo(
                            endPixel.x - arrowSize * Math.cos(angle + Math.PI / 6),
                            endPixel.y + arrowSize * Math.sin(angle + Math.PI / 6)
                        );
                        ctx.stroke();
                    }

                    ctx.restore();

                    // Badge "correct" sur l'enonce
                    if (p > 0.8) {
                        const checkOpacity = (p - 0.8) / 0.2;
                        renderer.drawText('✓', -10.8, assoc.from.y + 0.3, {
                            font: 'bold 20px Arial',
                            color: `rgba(16, 185, 129, ${checkOpacity})`,
                            align: 'center'
                        });
                    }
                }
            });

            // Message final
            if (correctionProgress > 0.85) {
                const finalOpacity = MathUtils.ease((correctionProgress - 0.85) / 0.15, 'easeOutQuad');
                drawMathBox('final-msg', '\\text{Choisissez toujours la methode la plus adaptee !}', 0, -4, {
                    opacity: finalOpacity,
                    fontSize: '1.3em',
                    color: '#059669',
                    bgColor: 'rgba(209, 250, 229, 0.98)',
                    borderColor: '#10b981',
                    borderWidth: 2
                });
            }
        }
    }
});


// === scenes.js ===

/**
 * Scenes - Récupération des scènes depuis le registre
 *
 * Les scènes sont définies dans js/scenarios/*.js
 * Chaque fichier de scène s'enregistre dans window.SCENE_REGISTRY
 */

// Récupérer les scènes du registre (remplies par les fichiers scenarios/*.js)
const SCENES = window.SCENE_REGISTRY || [];

// Ancien code conservé pour référence - SUPPRIMER si le registre fonctionne
const SCENES_OLD = [
    // ============================================
    // SCÈNE 1 : INTRODUCTION
    // ============================================
    {
        id: 'intro',
        title: 'Introduction',
        duration: 4000,

        animate(localTime, progress, renderer, state) {
            const opacity = MathUtils.ease(progress, 'easeOutQuad');

            renderer.drawText('Le Produit Scalaire', 0, 0, {
                font: 'bold 48px Arial',
                color: `rgba(37, 99, 235, ${opacity})`,
                align: 'center'
            });
        }
    },

    // ============================================
    // SCÈNE 2 : NORME D'UN VECTEUR
    // ============================================
    {
        id: 'norme',
        title: 'Norme d\'un vecteur',
        duration: 8000,

        animate(localTime, progress, renderer, state) {
            // Coordonnées du vecteur u
            const ux = 4, uy = 3;

            // Phase 1 : Apparition du vecteur (0-30%)
            if (progress < 0.3) {
                const p = progress / 0.3;
                const len = MathUtils.ease(p, 'easeOutQuad');

                renderer.drawVector(0, 0, ux * len, uy * len, {
                    color: '#ef4444',
                    width: 3
                });

                if (p > 0.5) {
                    const labelOpacity = MathUtils.ease((p - 0.5) / 0.5, 'easeOutQuad');
                    renderer.drawText('u', ux + 0.3, uy + 0.3, {
                        color: `rgba(239, 68, 68, ${labelOpacity})`,
                        font: 'bold 24px Arial'
                    });
                }
            }
            // Phase 2 : Triangle rectangle (30-60%)
            else if (progress < 0.6) {
                const p = (progress - 0.3) / 0.3;

                // Vecteur complet
                renderer.drawVector(0, 0, ux, uy, {
                    color: '#ef4444',
                    width: 3
                });
                renderer.drawText('u', ux + 0.3, uy + 0.3, {
                    color: '#ef4444',
                    font: 'bold 24px Arial'
                });

                // Triangle rectangle progressif
                const triangleOpacity = MathUtils.ease(p, 'easeOutQuad');

                // Côté horizontal
                renderer.drawSegment(0, 0, ux, 0, {
                    color: `rgba(59, 130, 246, ${triangleOpacity})`,
                    width: 2,
                    dashed: true
                });

                // Côté vertical
                renderer.drawSegment(ux, 0, ux, uy, {
                    color: `rgba(59, 130, 246, ${triangleOpacity})`,
                    width: 2,
                    dashed: true
                });

                // Labels des côtés
                if (p > 0.3) {
                    const labelOp = MathUtils.ease((p - 0.3) / 0.7, 'easeOutQuad');
                    renderer.drawText('4', ux / 2, -0.5, {
                        color: `rgba(59, 130, 246, ${labelOp})`,
                        font: '18px Arial',
                        align: 'center'
                    });
                    renderer.drawText('3', ux + 0.5, uy / 2, {
                        color: `rgba(59, 130, 246, ${labelOp})`,
                        font: '18px Arial'
                    });
                }
            }
            // Phase 3 : Formule et calcul (60-100%)
            else {
                const p = (progress - 0.6) / 0.4;

                // Tout le contenu précédent
                renderer.drawVector(0, 0, ux, uy, {
                    color: '#ef4444',
                    width: 3
                });
                renderer.drawText('u', ux + 0.3, uy + 0.3, {
                    color: '#ef4444',
                    font: 'bold 24px Arial'
                });

                renderer.drawSegment(0, 0, ux, 0, {
                    color: 'rgba(59, 130, 246, 0.7)',
                    width: 2,
                    dashed: true
                });
                renderer.drawSegment(ux, 0, ux, uy, {
                    color: 'rgba(59, 130, 246, 0.7)',
                    width: 2,
                    dashed: true
                });
                renderer.drawText('4', ux / 2, -0.5, {
                    color: '#3b82f6',
                    font: '18px Arial',
                    align: 'center'
                });
                renderer.drawText('3', ux + 0.5, uy / 2, {
                    color: '#3b82f6',
                    font: '18px Arial'
                });

                // Formule et calcul apparaissent ligne par ligne
                const lines = [
                    '||u|| = √(x² + y²)',
                    '||u|| = √(4² + 3²)',
                    '||u|| = √(16 + 9)',
                    '||u|| = √25 = 5'
                ];

                const lineDelay = 0.2;
                lines.forEach((line, i) => {
                    const lineStart = i * lineDelay;
                    if (p > lineStart) {
                        const lineProgress = Math.min((p - lineStart) / lineDelay, 1);
                        const opacity = MathUtils.ease(lineProgress, 'easeOutQuad');

                        renderer.drawText(line, 0, -2.5 - i * 0.6, {
                            color: `rgba(37, 99, 235, ${opacity})`,
                            font: i === 3 ? 'bold 22px Arial' : '20px Arial',
                            align: 'center'
                        });
                    }
                });
            }

            // Stocker pour la suite
            state.uNorm = 5;
        }
    },

    // ============================================
    // SCÈNE 3 : DEUX VECTEURS
    // ============================================
    {
        id: 'deux-vecteurs',
        title: 'Deux vecteurs',
        duration: 6000,

        animate(localTime, progress, renderer, state) {
            const ux = 4, uy = 0;
            const vx = 3, vy = 3;

            // Phase 1 : Vecteur u (0-40%)
            if (progress < 0.4) {
                const p = progress / 0.4;
                const len = MathUtils.ease(p, 'easeOutQuad');

                renderer.drawVector(0, 0, ux * len, uy * len, {
                    color: '#ef4444',
                    width: 3
                });

                if (p > 0.5) {
                    const labelOpacity = MathUtils.ease((p - 0.5) / 0.5, 'easeOutQuad');
                    renderer.drawText('u', ux + 0.3, 0.3, {
                        color: `rgba(239, 68, 68, ${labelOpacity})`,
                        font: 'bold 24px Arial'
                    });
                }
            }
            // Phase 2 : Vecteur v apparaît (40-100%)
            else {
                const p = (progress - 0.4) / 0.6;

                // Vecteur u complet
                renderer.drawVector(0, 0, ux, uy, {
                    color: '#ef4444',
                    width: 3
                });
                renderer.drawText('u', ux + 0.3, 0.3, {
                    color: '#ef4444',
                    font: 'bold 24px Arial'
                });

                // Vecteur v avec rotation depuis l'axe x
                const len = MathUtils.ease(Math.min(p * 2, 1), 'easeOutQuad');
                const angle = MathUtils.ease(Math.min(p * 1.5, 1), 'easeOutQuad') * Math.PI / 4;

                const currentVx = len * vx * MathUtils.cos(angle) / Math.sqrt(vx * vx + vy * vy);
                const currentVy = len * vx * MathUtils.sin(angle) / Math.sqrt(vx * vx + vy * vy);
                const scaledLen = len * Math.sqrt(vx * vx + vy * vy);

                renderer.drawVector(0, 0, scaledLen * MathUtils.cos(angle), scaledLen * MathUtils.sin(angle), {
                    color: '#3b82f6',
                    width: 3
                });

                if (p > 0.5) {
                    const labelOpacity = MathUtils.ease((p - 0.5) / 0.5, 'easeOutQuad');
                    const finalVx = scaledLen * MathUtils.cos(angle);
                    const finalVy = scaledLen * MathUtils.sin(angle);
                    renderer.drawText('v', finalVx + 0.3, finalVy + 0.3, {
                        color: `rgba(59, 130, 246, ${labelOpacity})`,
                        font: 'bold 24px Arial'
                    });
                }
            }

            // Stocker les vecteurs
            state.ux = ux;
            state.uy = uy;
            state.vx = vx;
            state.vy = vy;
        }
    },

    // ============================================
    // SCÈNE 4 : ANGLE ENTRE LES VECTEURS
    // ============================================
    {
        id: 'angle',
        title: 'Angle θ',
        duration: 6000,

        animate(localTime, progress, renderer, state) {
            const ux = state.ux || 4;
            const uy = state.uy || 0;
            const vx = state.vx || 3;
            const vy = state.vy || 3;
            const angle = Math.PI / 4; // 45°

            // Vecteurs complets
            renderer.drawVector(0, 0, ux, uy, {
                color: '#ef4444',
                width: 3
            });
            renderer.drawText('u', ux + 0.3, 0.3, {
                color: '#ef4444',
                font: 'bold 24px Arial'
            });

            renderer.drawVector(0, 0, vx, vy, {
                color: '#3b82f6',
                width: 3
            });
            renderer.drawText('v', vx + 0.3, vy + 0.3, {
                color: '#3b82f6',
                font: 'bold 24px Arial'
            });

            // Phase 1 : Arc de l'angle (0-50%)
            if (progress < 0.5) {
                const p = progress / 0.5;
                const arcProgress = MathUtils.ease(p, 'easeOutQuad');
                const arcAngle = angle * arcProgress;

                renderer.drawArc(0, 0, 1.5, 0, arcAngle, {
                    color: '#10b981',
                    lineWidth: 2
                });

                if (p > 0.5) {
                    const labelOpacity = MathUtils.ease((p - 0.5) / 0.5, 'easeOutQuad');
                    renderer.drawText('θ', 1.2, 0.4, {
                        color: `rgba(16, 185, 129, ${labelOpacity})`,
                        font: 'bold 20px Arial'
                    });
                }
            }
            // Phase 2 : Affichage de l'angle et formule (50-100%)
            else {
                const p = (progress - 0.5) / 0.5;

                // Arc complet
                renderer.drawArc(0, 0, 1.5, 0, angle, {
                    color: '#10b981',
                    lineWidth: 2
                });
                renderer.drawText('θ', 1.2, 0.4, {
                    color: '#10b981',
                    font: 'bold 20px Arial'
                });

                // Label de l'angle
                if (p > 0.2) {
                    const angleOpacity = MathUtils.ease((p - 0.2) / 0.3, 'easeOutQuad');
                    renderer.drawText('θ = 45°', 2, 0.8, {
                        color: `rgba(16, 185, 129, ${angleOpacity})`,
                        font: 'bold 20px Arial'
                    });
                }

                // Formule géométrique
                if (p > 0.5) {
                    const formulaOpacity = MathUtils.ease((p - 0.5) / 0.5, 'easeOutQuad');
                    renderer.drawText('u · v = ||u|| × ||v|| × cos(θ)', 0, -3, {
                        color: `rgba(37, 99, 235, ${formulaOpacity})`,
                        font: 'bold 24px Arial',
                        align: 'center'
                    });
                }
            }

            state.angle = angle;
        }
    },

    // ============================================
    // SCÈNE 5 : CALCUL GÉOMÉTRIQUE
    // ============================================
    {
        id: 'calcul-geometrique',
        title: 'Calcul géométrique',
        duration: 10000,

        animate(localTime, progress, renderer, state) {
            const ux = state.ux || 4;
            const uy = state.uy || 0;
            const vx = state.vx || 3;
            const vy = state.vy || 3;
            const angle = state.angle || Math.PI / 4;

            // Éléments graphiques (toujours visibles)
            renderer.drawVector(0, 0, ux, uy, {
                color: '#ef4444',
                width: 3
            });
            renderer.drawText('u', ux + 0.3, 0.3, {
                color: '#ef4444',
                font: 'bold 24px Arial'
            });

            renderer.drawVector(0, 0, vx, vy, {
                color: '#3b82f6',
                width: 3
            });
            renderer.drawText('v', vx + 0.3, vy + 0.3, {
                color: '#3b82f6',
                font: 'bold 24px Arial'
            });

            renderer.drawArc(0, 0, 1.5, 0, angle, {
                color: '#10b981',
                lineWidth: 2
            });
            renderer.drawText('θ', 1.2, 0.4, {
                color: '#10b981',
                font: 'bold 20px Arial'
            });

            // Calcul étape par étape
            const vNorm = Math.sqrt(vx * vx + vy * vy);
            const lines = [
                'u · v = ||u|| × ||v|| × cos(θ)',
                `u · v = 4 × ${MathUtils.format(vNorm, 2)} × cos(45°)`,
                `u · v = ${MathUtils.format(4 * vNorm, 2)} × (√2/2)`,
                `u · v = 12`
            ];

            const lineDelay = 0.2;
            lines.forEach((line, i) => {
                const lineStart = i * lineDelay;
                if (progress > lineStart) {
                    const lineProgress = Math.min((progress - lineStart) / lineDelay, 1);
                    const opacity = MathUtils.ease(lineProgress, 'easeOutQuad');

                    renderer.drawText(line, 0, -2.5 - i * 0.7, {
                        color: `rgba(37, 99, 235, ${opacity})`,
                        font: i === 3 ? 'bold 26px Arial' : '20px Arial',
                        align: 'center'
                    });
                }
            });

            state.dotProduct = 12;
        }
    },

    // ============================================
    // SCÈNE 6 : PROJECTION ORTHOGONALE
    // ============================================
    {
        id: 'projection',
        title: 'Projection orthogonale',
        duration: 8000,

        animate(localTime, progress, renderer, state) {
            const ux = state.ux || 4;
            const uy = state.uy || 0;
            const vx = state.vx || 3;
            const vy = state.vy || 3;

            // Vecteurs
            renderer.drawVector(0, 0, ux, uy, {
                color: '#ef4444',
                width: 3
            });
            renderer.drawText('u', ux + 0.3, 0.3, {
                color: '#ef4444',
                font: 'bold 24px Arial'
            });

            renderer.drawVector(0, 0, vx, vy, {
                color: '#3b82f6',
                width: 3
            });
            renderer.drawText('v', vx + 0.3, vy + 0.3, {
                color: '#3b82f6',
                font: 'bold 24px Arial'
            });

            // Phase 1 : Point H apparaît (0-30%)
            const dotProduct = ux * vx + uy * vy;
            const uNormSq = ux * ux + uy * uy;
            const projScalar = dotProduct / uNormSq;
            const hx = projScalar * ux;
            const hy = projScalar * uy;

            if (progress > 0.1) {
                const p = Math.min((progress - 0.1) / 0.3, 1);
                const pointProgress = MathUtils.ease(p, 'easeOutQuad');

                // Segment perpendiculaire
                const perpOpacity = pointProgress;
                renderer.drawSegment(vx, vy, hx, hy, {
                    color: `rgba(155, 89, 182, ${perpOpacity})`,
                    width: 2,
                    dashed: true
                });

                // Point H
                renderer.drawPoint(hx, hy, {
                    radius: 6,
                    color: '#9b59b6'
                });

                if (p > 0.5) {
                    const labelOpacity = MathUtils.ease((p - 0.5) / 0.5, 'easeOutQuad');
                    renderer.drawText('H', hx, hy - 0.5, {
                        color: `rgba(155, 89, 182, ${labelOpacity})`,
                        font: 'bold 20px Arial',
                        align: 'center'
                    });
                }
            }

            // Phase 2 : Vecteur OH (40-60%)
            if (progress > 0.4) {
                const p = Math.min((progress - 0.4) / 0.2, 1);
                const vectorProgress = MathUtils.ease(p, 'easeOutQuad');

                const currentHx = hx * vectorProgress;
                const currentHy = hy * vectorProgress;

                renderer.drawVector(0, 0, currentHx, currentHy, {
                    color: '#9b59b6',
                    width: 3
                });

                if (p > 0.5) {
                    const labelOpacity = MathUtils.ease((p - 0.5) / 0.5, 'easeOutQuad');
                    renderer.drawText('OH', currentHx / 2, currentHy / 2 - 0.4, {
                        color: `rgba(155, 89, 182, ${labelOpacity})`,
                        font: 'bold 20px Arial',
                        align: 'center'
                    });
                }
            }

            // Phase 3 : Formules (60-100%)
            if (progress > 0.6) {
                const p = (progress - 0.6) / 0.4;

                const lines = [
                    'u · v = ||u|| × OH',
                    `u · v = 4 × 3 = 12`,
                    `(avec OH = ||v||cos(θ) = 3)`
                ];

                const lineDelay = 0.25;
                lines.forEach((line, i) => {
                    const lineStart = i * lineDelay;
                    if (p > lineStart) {
                        const lineProgress = Math.min((p - lineStart) / lineDelay, 1);
                        const opacity = MathUtils.ease(lineProgress, 'easeOutQuad');

                        renderer.drawText(line, 0, -3 - i * 0.7, {
                            color: `rgba(155, 89, 182, ${opacity})`,
                            font: i === 1 ? 'bold 24px Arial' : '18px Arial',
                            align: 'center'
                        });
                    }
                });
            }
        }
    },

    // ============================================
    // SCÈNE 7 : FORMULE ANALYTIQUE
    // ============================================
    {
        id: 'analytique',
        title: 'Formule analytique',
        duration: 8000,

        animate(localTime, progress, renderer, state) {
            const ux = state.ux || 4;
            const uy = state.uy || 0;
            const vx = state.vx || 3;
            const vy = state.vy || 3;

            // Vecteurs
            renderer.drawVector(0, 0, ux, uy, {
                color: '#ef4444',
                width: 3
            });
            renderer.drawVector(0, 0, vx, vy, {
                color: '#3b82f6',
                width: 3
            });

            // Phase 1 : Coordonnées apparaissent (0-30%)
            if (progress > 0) {
                const p = Math.min(progress / 0.3, 1);
                const coordOpacity = MathUtils.ease(p, 'easeOutQuad');

                renderer.drawText(`u(${ux}, ${uy})`, ux + 0.5, 0.3, {
                    color: `rgba(239, 68, 68, ${coordOpacity})`,
                    font: 'bold 22px Arial'
                });

                renderer.drawText(`v(${vx}, ${vy})`, vx + 0.5, vy + 0.3, {
                    color: `rgba(59, 130, 246, ${coordOpacity})`,
                    font: 'bold 22px Arial'
                });
            }

            // Phase 2 : Formule générale (30-50%)
            if (progress > 0.3) {
                const p = Math.min((progress - 0.3) / 0.2, 1);
                const formulaOpacity = MathUtils.ease(p, 'easeOutQuad');

                renderer.drawText('u · v = xu × xv + yu × yv', 0, -2.5, {
                    color: `rgba(37, 99, 235, ${formulaOpacity})`,
                    font: 'bold 24px Arial',
                    align: 'center'
                });
            }

            // Phase 3 : Calcul étape par étape (50-100%)
            if (progress > 0.5) {
                const p = (progress - 0.5) / 0.5;

                const lines = [
                    'u · v = xu × xv + yu × yv',
                    `u · v = ${ux} × ${vx} + ${uy} × ${vy}`,
                    `u · v = 12 + 0`,
                    `u · v = 12`
                ];

                const lineDelay = 0.2;
                lines.forEach((line, i) => {
                    const lineStart = i * lineDelay;
                    if (p > lineStart) {
                        const lineProgress = Math.min((p - lineStart) / lineDelay, 1);
                        const opacity = MathUtils.ease(lineProgress, 'easeOutQuad');

                        renderer.drawText(line, 0, -2.5 - i * 0.7, {
                            color: `rgba(37, 99, 235, ${opacity})`,
                            font: i === 3 ? 'bold 26px Arial' : '20px Arial',
                            align: 'center'
                        });
                    }
                });

                // Message "Même résultat !"
                if (p > 0.8) {
                    const msgOpacity = MathUtils.ease((p - 0.8) / 0.2, 'easeOutQuad');
                    renderer.drawText('✓ Même résultat !', 0, -6, {
                        color: `rgba(16, 185, 129, ${msgOpacity})`,
                        font: 'bold 22px Arial',
                        align: 'center'
                    });
                }
            }
        }
    },

    // ============================================
    // SCÈNE 8 : ORTHOGONALITÉ
    // ============================================
    {
        id: 'orthogonalite',
        title: 'Orthogonalité',
        duration: 10000,

        animate(localTime, progress, renderer, state) {
            // Nouveaux vecteurs orthogonaux
            const ux = 3, uy = 2;
            const vx = -2, vy = 3;

            // Phase 1 : Transition - nouveaux vecteurs apparaissent (0-25%)
            if (progress < 0.25) {
                const p = progress / 0.25;
                const len = MathUtils.ease(p, 'easeOutQuad');

                renderer.drawVector(0, 0, ux * len, uy * len, {
                    color: '#ef4444',
                    width: 3
                });

                if (p > 0.3) {
                    const vProgress = MathUtils.ease((p - 0.3) / 0.7, 'easeOutQuad');
                    renderer.drawVector(0, 0, vx * vProgress, vy * vProgress, {
                        color: '#3b82f6',
                        width: 3
                    });
                }
            }
            // Phase 2 : Calcul du produit scalaire (25-60%)
            else if (progress < 0.6) {
                const p = (progress - 0.25) / 0.35;

                // Vecteurs complets
                renderer.drawVector(0, 0, ux, uy, {
                    color: '#ef4444',
                    width: 3
                });
                renderer.drawText(`u(${ux}, ${uy})`, ux + 0.3, uy + 0.3, {
                    color: '#ef4444',
                    font: 'bold 20px Arial'
                });

                renderer.drawVector(0, 0, vx, vy, {
                    color: '#3b82f6',
                    width: 3
                });
                renderer.drawText(`v(${vx}, ${vy})`, vx - 1.2, vy + 0.3, {
                    color: '#3b82f6',
                    font: 'bold 20px Arial'
                });

                // Calcul
                const lines = [
                    `u · v = ${ux} × (${vx}) + ${uy} × ${vy}`,
                    `u · v = ${ux * vx} + ${uy * vy}`,
                    `u · v = 0`
                ];

                const lineDelay = 0.25;
                lines.forEach((line, i) => {
                    const lineStart = i * lineDelay;
                    if (p > lineStart) {
                        const lineProgress = Math.min((p - lineStart) / lineDelay, 1);
                        const opacity = MathUtils.ease(lineProgress, 'easeOutQuad');

                        renderer.drawText(line, 0, -3 - i * 0.7, {
                            color: `rgba(37, 99, 235, ${opacity})`,
                            font: i === 2 ? 'bold 26px Arial' : '20px Arial',
                            align: 'center'
                        });
                    }
                });
            }
            // Phase 3 : Angle droit visible (60-100%)
            else {
                const p = (progress - 0.6) / 0.4;

                // Vecteurs
                renderer.drawVector(0, 0, ux, uy, {
                    color: '#ef4444',
                    width: 3
                });
                renderer.drawVector(0, 0, vx, vy, {
                    color: '#3b82f6',
                    width: 3
                });

                // Carré de l'angle droit
                if (p > 0.1) {
                    const squareSize = 0.5;
                    const squareOpacity = MathUtils.ease((p - 0.1) / 0.2, 'easeOutQuad');

                    const uNorm = Math.sqrt(ux * ux + uy * uy);
                    const vNorm = Math.sqrt(vx * vx + vy * vy);

                    const ux_norm = ux / uNorm * squareSize;
                    const uy_norm = uy / uNorm * squareSize;
                    const vx_norm = vx / vNorm * squareSize;
                    const vy_norm = vy / vNorm * squareSize;

                    renderer.drawSegment(ux_norm, uy_norm, ux_norm + vx_norm, uy_norm + vy_norm, {
                        color: `rgba(16, 185, 129, ${squareOpacity})`,
                        width: 2
                    });
                    renderer.drawSegment(ux_norm + vx_norm, uy_norm + vy_norm, vx_norm, vy_norm, {
                        color: `rgba(16, 185, 129, ${squareOpacity})`,
                        width: 2
                    });
                    renderer.drawSegment(ux_norm, uy_norm, 0, 0, {
                        color: `rgba(16, 185, 129, ${squareOpacity})`,
                        width: 2
                    });
                    renderer.drawSegment(vx_norm, vy_norm, 0, 0, {
                        color: `rgba(16, 185, 129, ${squareOpacity})`,
                        width: 2
                    });
                }

                // Message "ORTHOGONAUX"
                if (p > 0.3) {
                    const msgOpacity = MathUtils.ease((p - 0.3) / 0.2, 'easeOutQuad');
                    renderer.drawText('Vecteurs ORTHOGONAUX', 0, -3, {
                        color: `rgba(59, 130, 246, ${msgOpacity})`,
                        font: 'bold 28px Arial',
                        align: 'center'
                    });
                }

                // Encadré de la propriété
                if (p > 0.5) {
                    const boxOpacity = MathUtils.ease((p - 0.5) / 0.3, 'easeOutQuad');
                    renderer.drawText('u ⊥ v  ⟺  u · v = 0', 0, -4.5, {
                        color: `rgba(37, 99, 235, ${boxOpacity})`,
                        font: 'bold 24px Arial',
                        align: 'center'
                    });
                }
            }
        }
    },

    // ============================================
    // SCÈNE 9 : SIGNE DU PRODUIT SCALAIRE
    // ============================================
    {
        id: 'signe',
        title: 'Signe du produit scalaire',
        duration: 12000,

        animate(localTime, progress, renderer, state) {
            const ux = 3, uy = 0;

            // Vecteur u fixe
            renderer.drawVector(0, 0, ux, uy, {
                color: '#ef4444',
                width: 3
            });
            renderer.drawText('u', ux + 0.3, 0.3, {
                color: '#ef4444',
                font: 'bold 24px Arial'
            });

            // Vecteur v tourne autour de l'origine
            const angle = progress * 2 * Math.PI;
            const vLen = 2.5;
            const vx = vLen * MathUtils.cos(angle);
            const vy = vLen * MathUtils.sin(angle);

            renderer.drawVector(0, 0, vx, vy, {
                color: '#3b82f6',
                width: 3
            });
            renderer.drawText('v', vx + 0.3, vy + 0.3, {
                color: '#3b82f6',
                font: 'bold 24px Arial'
            });

            // Calcul du produit scalaire
            const dotProduct = ux * vx + uy * vy;
            const angleDeg = (angle * 180 / Math.PI) % 360;

            // Déterminer la couleur et le message
            let color, message, bgColor;
            if (Math.abs(dotProduct) < 0.3) {
                color = '#3b82f6';
                message = 'Angle droit (θ = 90°)';
                bgColor = 'rgba(59, 130, 246, 0.1)';
            } else if (dotProduct > 0) {
                color = '#10b981';
                message = 'Angle aigu (θ < 90°)';
                bgColor = 'rgba(16, 185, 129, 0.1)';
            } else {
                color = '#f97316';
                message = 'Angle obtus (θ > 90°)';
                bgColor = 'rgba(249, 115, 22, 0.1)';
            }

            // Zone colorée de fond
            if (progress > 0.1) {
                const sectors = [
                    { start: -Math.PI / 2, end: Math.PI / 2, color: 'rgba(16, 185, 129, 0.15)' }, // vert
                    { start: Math.PI / 2 - 0.1, end: Math.PI / 2 + 0.1, color: 'rgba(59, 130, 246, 0.2)' }, // bleu
                    { start: Math.PI / 2, end: 3 * Math.PI / 2, color: 'rgba(249, 115, 22, 0.15)' }, // orange
                    { start: 3 * Math.PI / 2 - 0.1, end: 3 * Math.PI / 2 + 0.1, color: 'rgba(59, 130, 246, 0.2)' }, // bleu
                ];

                sectors.forEach(sector => {
                    for (let a = sector.start; a < sector.end; a += 0.05) {
                        const r = 5;
                        const x1 = r * MathUtils.cos(a);
                        const y1 = r * MathUtils.sin(a);
                        renderer.drawSegment(0, 0, x1, y1, {
                            color: sector.color,
                            width: 20,
                            alpha: 0.3
                        });
                    }
                });
            }

            // Affichage des informations
            renderer.drawText(`u · v = ${MathUtils.format(dotProduct, 2)}`, 0, -3.5, {
                color: color,
                font: 'bold 28px Arial',
                align: 'center'
            });

            renderer.drawText(`θ = ${MathUtils.format(angleDeg, 1)}°`, 0, -4.5, {
                color: '#64748b',
                font: '20px Arial',
                align: 'center'
            });

            renderer.drawText(message, 0, -5.5, {
                color: color,
                font: 'bold 22px Arial',
                align: 'center'
            });
        }
    },

    // ============================================
    // SCÈNE 10 : RÉCAPITULATIF
    // ============================================
    {
        id: 'recap',
        title: 'Récapitulatif',
        duration: 6000,

        animate(localTime, progress, renderer, state) {
            const formulas = [
                {
                    title: 'Formule géométrique',
                    formula: 'u · v = ||u|| × ||v|| × cos(θ)',
                    y: 1.5,
                    color: '#10b981'
                },
                {
                    title: 'Formule analytique',
                    formula: 'u · v = xu × xv + yu × yv',
                    y: -0.5,
                    color: '#3b82f6'
                },
                {
                    title: 'Critère d\'orthogonalité',
                    formula: 'u ⊥ v  ⟺  u · v = 0',
                    y: -2.5,
                    color: '#ef4444'
                }
            ];

            formulas.forEach((item, i) => {
                const startTime = i * 0.25;
                if (progress > startTime) {
                    const p = Math.min((progress - startTime) / 0.2, 1);
                    const opacity = MathUtils.ease(p, 'easeOutQuad');
                    const offset = (1 - p) * 0.3;

                    // Titre
                    renderer.drawText(item.title, 0, item.y + offset, {
                        color: `rgba(100, 116, 139, ${opacity})`,
                        font: 'bold 18px Arial',
                        align: 'center'
                    });

                    // Formule encadrée
                    renderer.drawText(item.formula, 0, item.y - 0.6 + offset, {
                        color: `${item.color.replace(')', `, ${opacity})`).replace('rgb', 'rgba')}`,
                        font: 'bold 24px Arial',
                        align: 'center'
                    });

                    // Ligne de séparation
                    if (i < formulas.length - 1 && p > 0.8) {
                        const lineOpacity = MathUtils.ease((p - 0.8) / 0.2, 'easeOutQuad') * opacity;
                        renderer.drawSegment(-3, item.y - 1.3, 3, item.y - 1.3, {
                            color: `rgba(226, 232, 240, ${lineOpacity})`,
                            width: 1
                        });
                    }
                }
            });
        }
    }
];

/**
 * Gestionnaire de scènes
 * Coordonne l'exécution des scènes avec la timeline
 */
const SceneManager = {
    scenes: [],
    currentState: {},
    renderer: null,

    /**
     * Initialiser avec les scènes
     */
    init(scenes, renderer) {
        this.scenes = scenes;
        this.renderer = renderer;
        this.currentState = {};
        return this;
    },

    /**
     * Obtenir les scènes formatées pour la timeline
     */
    getScenesForTimeline() {
        return this.scenes.map(scene => ({
            id: scene.id,
            title: scene.title,
            duration: scene.duration
        }));
    },

    /**
     * Rendre la frame actuelle
     * Appelé par la timeline à chaque mise à jour
     */
    render(currentTime, sceneData) {
        if (!this.renderer || !sceneData || !sceneData.scene) return;

        const scene = this.scenes.find(s => s.id === sceneData.scene.id);
        if (!scene || !scene.animate) return;

        // Appeler la fonction d'animation de la scène
        scene.animate(
            sceneData.localTime,
            sceneData.progress,
            this.renderer,
            this.currentState
        );
    },

    /**
     * Réinitialiser l'état
     */
    reset() {
        this.currentState = {};
    }
};

/**
 * Helpers pour créer des animations complexes
 */
const AnimationHelpers = {
    /**
     * Animation de morphing entre deux valeurs
     */
    morph(from, to, progress, easing = 'easeInOutQuad') {
        const t = MathUtils.ease(progress, easing);
        if (typeof from === 'number') {
            return MathUtils.lerp(from, to, t);
        }
        // Pour les objets {x, y}
        return {
            x: MathUtils.lerp(from.x, to.x, t),
            y: MathUtils.lerp(from.y, to.y, t)
        };
    },

    /**
     * Animation séquencée (plusieurs étapes dans une scène)
     * @param progress - Progression totale (0-1)
     * @param steps - Array de {at, duration, fn}
     */
    sequence(progress, steps) {
        const totalDuration = steps.reduce((sum, s) => sum + (s.duration || 1), 0);
        let currentTime = progress * totalDuration;

        for (const step of steps) {
            const stepDuration = step.duration || 1;
            if (currentTime <= stepDuration) {
                const stepProgress = currentTime / stepDuration;
                return step.fn(stepProgress);
            }
            currentTime -= stepDuration;
        }
    },

    /**
     * Délai avant de commencer (retourne 0 puis progress ajusté)
     */
    delay(progress, delayRatio) {
        if (progress < delayRatio) return 0;
        return (progress - delayRatio) / (1 - delayRatio);
    },

    /**
     * Animation qui se répète
     */
    loop(progress, count = 1) {
        return (progress * count) % 1;
    },

    /**
     * Animation qui va et vient
     */
    pingPong(progress) {
        return progress < 0.5
            ? progress * 2
            : 2 - progress * 2;
    },

    /**
     * Apparition progressive (fade in)
     */
    fadeIn(progress, start = 0, end = 0.3) {
        if (progress < start) return 0;
        if (progress > end) return 1;
        return (progress - start) / (end - start);
    },

    /**
     * Disparition progressive (fade out)
     */
    fadeOut(progress, start = 0.7, end = 1) {
        if (progress < start) return 1;
        if (progress > end) return 0;
        return 1 - (progress - start) / (end - start);
    },

    /**
     * Écriture progressive d'un texte
     */
    typewriter(text, progress) {
        const len = Math.floor(text.length * progress);
        return text.substring(0, len);
    },

    /**
     * Tracé progressif d'une courbe (pour les fonctions)
     */
    drawProgressively(fn, progress, renderer, options = {}) {
        const { minX = -5, maxX = 5, color = '#2563eb', lineWidth = 2 } = options;
        const effectiveMaxX = MathUtils.lerp(minX, maxX, progress);

        renderer.drawFunction(fn, {
            minX,
            maxX: effectiveMaxX,
            color,
            lineWidth
        });
    }
};


// === main.js ===

/**
 * MAIN - Point d'entrée de l'application
 * Gère les deux modes : Animation (capsule vidéo) et Interactif (exploration)
 */

// ==========================================
// INSTANCES GLOBALES
// ==========================================
let animationRenderer, interactiveRenderer;
let animationCore, interactiveCore;
let timeline, sceneManager, controls;
let currentMode = 'animation';

// ==========================================
// INITIALISATION
// ==========================================

document.addEventListener('DOMContentLoaded', () => {
    console.log('[Main] Initializing...');

    initRenderers();
    initModes();
    initModeSwitch();
    initGlobalControls();
    initHelp();

    // Démarrer en mode animation par défaut
    switchMode('animation');

    console.log('[Main] Ready');
});

// ==========================================
// INITIALISATION DES RENDERERS
// ==========================================

function initRenderers() {
    // Renderer pour le mode animation
    const animCanvas = document.getElementById('animation-canvas');
    if (animCanvas) {
        animationRenderer = new CanvasRenderer('animation-canvas');
    }

    // Renderer pour le mode interactif
    const interCanvas = document.getElementById('interactive-canvas');
    if (interCanvas) {
        interactiveRenderer = new CanvasRenderer('interactive-canvas');
    }
}

// ==========================================
// INITIALISATION DES MODES
// ==========================================

function initModes() {
    // ----- MODE ANIMATION -----
    if (animationRenderer && typeof SCENES !== 'undefined') {
        // Initialiser les helpers de rendu
        if (typeof MathOverlay !== 'undefined') {
            MathOverlay.init(animationRenderer);
        }
        if (typeof TransitionManager !== 'undefined') {
            TransitionManager.init();
        }

        // Initialiser le gestionnaire de scènes
        sceneManager = SceneManager.init(SCENES, animationRenderer);

        // Initialiser la timeline
        timeline = Timeline.init(sceneManager.getScenesForTimeline(), {
            onTimeUpdate: (currentTime, sceneData) => {
                // Debut de frame - marquer les elements MathJax comme inactifs
                if (typeof MathOverlay !== 'undefined') {
                    MathOverlay.beginFrame();
                }

                // Effacer et redessiner le canvas
                animationRenderer.clear();

                // Verifier si la scene actuelle desactive la grille/axes (ex: recap)
                const currentScene = sceneManager.scenes.find(s => s.id === sceneData.scene.id);
                const hideGrid = currentScene && currentScene.hideGrid;
                const hideAxes = currentScene && currentScene.hideAxes;

                if (!hideGrid) {
                    animationRenderer.drawGrid();
                }
                if (!hideAxes) {
                    animationRenderer.drawAxes();
                }

                // Rendre la scene actuelle
                sceneManager.render(currentTime, sceneData);

                // Fin de frame - supprimer les elements MathJax non utilises
                if (typeof MathOverlay !== 'undefined') {
                    MathOverlay.endFrame();
                }
            },
            onSceneChange: (sceneData) => {
                console.log(`[Scene] ${sceneData.scene.title}`);
                // Effacer l'overlay MathJax lors du changement de scène
                if (typeof MathOverlay !== 'undefined') {
                    MathOverlay.clear();
                }
            }
        });

        // Boucle de rendu pour le mode animation
        animationCore = new AnimationCore(animationRenderer);
        animationCore.onUpdate = () => {
            // La timeline gère les mises à jour
        };
        animationCore.onRender = () => {
            // Le rendu est géré par la timeline
        };
    }

    // ----- MODE INTERACTIF -----
    if (interactiveRenderer) {
        // Initialiser les contrôles
        controls = new Controls();

        // Initialiser AnimationLogic si défini
        if (typeof AnimationLogic !== 'undefined') {
            AnimationLogic.init(interactiveRenderer, null, controls);
        }

        // Boucle de rendu pour le mode interactif
        interactiveCore = new AnimationCore(interactiveRenderer);
        interactiveCore.onUpdate = (deltaTime, elapsedTime) => {
            applyDisplayParams();
            if (typeof AnimationLogic !== 'undefined') {
                AnimationLogic.update(deltaTime, elapsedTime);
            }
            updateInfoOverlay();
        };
        interactiveCore.onRender = (renderer) => {
            if (typeof AnimationLogic !== 'undefined') {
                AnimationLogic.render(renderer);
            }
        };

        // Configurer les interactions
        setupInteractiveInteractions();
    }

    // Initialiser la bulle de contrôles
    initControlsBubble();
}

// ==========================================
// CHANGEMENT DE MODE
// ==========================================

function initModeSwitch() {
    const tabs = document.querySelectorAll('.menu-tab');

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const mode = tab.dataset.mode;
            switchMode(mode);

            // Mettre à jour l'UI
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
        });
    });
}

function switchMode(mode) {
    currentMode = mode;

    // Cacher tous les conteneurs de mode
    document.querySelectorAll('.mode-container').forEach(c => {
        c.classList.remove('active');
    });

    // Afficher le mode sélectionné
    const modeContainer = document.getElementById(`mode-${mode}`);
    if (modeContainer) {
        modeContainer.classList.add('active');
    }

    // Gérer les animations
    if (mode === 'animation') {
        // Arrêter le mode interactif
        interactiveCore?.pause();

        // Le mode animation est piloté par la timeline
        // (pas besoin de démarrer animationCore, la timeline gère tout)

    } else if (mode === 'interactive') {
        // Mettre en pause la timeline
        timeline?.pause();

        // Démarrer le mode interactif
        interactiveCore?.start();
    }
}

// ==========================================
// BULLE DE CONTRÔLES (MODE INTERACTIF)
// ==========================================

function initControlsBubble() {
    const bubble = document.getElementById('controls-bubble');
    const toggle = document.getElementById('bubble-toggle');
    const close = document.getElementById('bubble-close');

    if (!bubble || !toggle) return;

    toggle.addEventListener('click', () => {
        bubble.classList.remove('collapsed');
    });

    close?.addEventListener('click', () => {
        bubble.classList.add('collapsed');
    });

    // Sections dépliables
    document.querySelectorAll('.section-header').forEach(header => {
        header.addEventListener('click', () => {
            const section = header.closest('.control-section');
            section?.classList.toggle('collapsed');
        });
    });

    // Initialiser les contrôles depuis AnimationLogic
    if (typeof AnimationLogic !== 'undefined' && AnimationLogic.setupControls) {
        AnimationLogic.setupControls();
    }
}

// ==========================================
// PARAMÈTRES D'AFFICHAGE
// ==========================================

function applyDisplayParams() {
    if (!controls || !interactiveRenderer) return;

    const params = controls.getAll();

    interactiveRenderer.config.showGrid = params.showGrid ?? true;
    interactiveRenderer.config.showAxes = params.showAxes ?? true;
    interactiveRenderer.config.showLabels = params.showLabels ?? true;
}

// ==========================================
// OVERLAY D'INFORMATIONS
// ==========================================

function updateInfoOverlay() {
    const overlay = document.getElementById('info-overlay');
    if (!overlay) return;

    let infoItems = [];

    if (typeof AnimationLogic !== 'undefined' && AnimationLogic.getInfoDisplay) {
        infoItems = AnimationLogic.getInfoDisplay();
    }

    if (infoItems.length === 0) {
        overlay.innerHTML = '';
        return;
    }

    overlay.innerHTML = infoItems.map(item => {
        let valueClass = 'value';
        if (item.positive) valueClass += ' positive';
        if (item.negative) valueClass += ' negative';
        if (item.zero) valueClass += ' zero';

        return `
            <div class="info-item">
                <span class="label">${item.label}</span>
                <span class="${valueClass}">${item.value}</span>
            </div>
        `;
    }).join('');
}

// ==========================================
// INTERACTIONS (MODE INTERACTIF)
// ==========================================

function setupInteractiveInteractions() {
    const canvas = document.getElementById('interactive-canvas');
    if (!canvas) return;

    let isDragging = false;
    let lastX, lastY;

    // Zoom avec la molette
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        interactiveRenderer.zoom(factor, e.offsetX, e.offsetY);
    }, { passive: false });

    // Pan
    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 2 || (e.button === 0 && e.ctrlKey)) {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            canvas.style.cursor = 'grabbing';
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            interactiveRenderer.pan(dx, dy);
            lastX = e.clientX;
            lastY = e.clientY;
        }

        // Notifier AnimationLogic
        const mathPos = interactiveRenderer.toMath(e.offsetX, e.offsetY);
        if (typeof AnimationLogic !== 'undefined' && AnimationLogic.onMouseMove) {
            AnimationLogic.onMouseMove(mathPos.x, mathPos.y, e);
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'default';
    });

    canvas.addEventListener('mouseleave', () => {
        isDragging = false;
        canvas.style.cursor = 'default';
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    canvas.addEventListener('click', (e) => {
        const mathPos = interactiveRenderer.toMath(e.offsetX, e.offsetY);
        if (typeof AnimationLogic !== 'undefined' && AnimationLogic.onClick) {
            AnimationLogic.onClick(mathPos.x, mathPos.y, e);
        }
    });

    canvas.addEventListener('dblclick', () => {
        interactiveRenderer.resetViewport();
    });
}

// ==========================================
// CONTRÔLES GLOBAUX
// ==========================================

function initGlobalControls() {
    // Plein écran
    document.getElementById('btn-fullscreen')?.addEventListener('click', () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            document.exitFullscreen();
        }
    });

    // Reset
    document.getElementById('btn-reset')?.addEventListener('click', () => {
        if (currentMode === 'animation') {
            timeline?.reset();
            sceneManager?.reset();
        } else {
            interactiveRenderer?.resetViewport();
            if (typeof AnimationLogic !== 'undefined' && AnimationLogic.resetState) {
                AnimationLogic.resetState();
            }
        }
    });

    // Aide
    const helpModal = document.getElementById('help-modal');
    document.getElementById('btn-help')?.addEventListener('click', () => {
        helpModal?.classList.remove('hidden');
    });
    document.getElementById('modal-close')?.addEventListener('click', () => {
        helpModal?.classList.add('hidden');
    });
    helpModal?.addEventListener('click', (e) => {
        if (e.target === helpModal) helpModal.classList.add('hidden');
    });

    // Échap pour fermer modal
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            helpModal?.classList.add('hidden');
        }
    });
}

// ==========================================
// AIDE
// ==========================================

function initHelp() {
    const helpContent = document.getElementById('help-content');
    if (!helpContent) return;

    // Ajouter le contenu personnalisé si disponible
    if (typeof AnimationLogic !== 'undefined' && AnimationLogic.getHelpContent) {
        const customHelp = AnimationLogic.getHelpContent();
        if (customHelp) {
            helpContent.innerHTML = `<h3>À propos</h3>${customHelp}<hr>` + helpContent.innerHTML;
        }
    }
}

// ==========================================
// EXPORT GLOBAL
// ==========================================

window.AnimationApp = {
    get mode() { return currentMode; },
    switchMode,
    timeline,
    sceneManager,
    controls,
    animationRenderer,
    interactiveRenderer,

    // Mode animation
    play: () => timeline?.play(),
    pause: () => timeline?.pause(),
    seek: (time) => timeline?.seek(time),
    goToScene: (index) => timeline?.goToScene(index),

    // Mode interactif
    setParam: (name, value) => controls?.set(name, value),
    getParam: (name) => controls?.get(name),
    resetView: () => interactiveRenderer?.resetViewport()
};


// === scenarios.js ===

/**
 * SCENARIOS
 * Gestion des scénarios d'animation guidés
 * Chaque scénario est une séquence d'étapes avec animations et descriptions
 */

class ScenarioManager {
    constructor(renderer, animation) {
        this.renderer = renderer;
        this.animation = animation;

        // Scénarios disponibles
        this.scenarios = [];

        // État courant
        this.currentScenario = null;
        this.currentStepIndex = 0;
        this.isPlaying = false;
        this.isPaused = false;

        // Contrôles en temps réel pendant le scénario
        this.realtimeParams = {};

        // Éléments DOM
        this.scenarioList = document.getElementById('scenario-list');
        this.scenarioCanvas = document.getElementById('scenario-canvas');
        this.scenarioDescription = document.getElementById('scenario-description');
        this.stepDisplay = document.getElementById('scenario-step');
        this.totalDisplay = document.getElementById('scenario-total');
        this.prevBtn = document.getElementById('scenario-prev');
        this.nextBtn = document.getElementById('scenario-next');

        // Renderer dédié aux scénarios
        if (this.scenarioCanvas) {
            this.scenarioRenderer = new CanvasRenderer('scenario-canvas');
        }

        // Initialisation
        this.init();
    }

    // ==========================================
    // INITIALISATION
    // ==========================================

    init() {
        this.setupNavigation();
        this.setupKeyboardShortcuts();
    }

    setupNavigation() {
        if (this.prevBtn) {
            this.prevBtn.addEventListener('click', () => this.previousStep());
        }
        if (this.nextBtn) {
            this.nextBtn.addEventListener('click', () => this.nextStep());
        }
    }

    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Seulement si la vue scénarios est active
            const view = document.getElementById('view-scenarios');
            if (!view || !view.classList.contains('active')) return;

            switch (e.key) {
                case 'ArrowLeft':
                    this.previousStep();
                    break;
                case 'ArrowRight':
                    this.nextStep();
                    break;
                case ' ':
                    e.preventDefault();
                    this.togglePlayPause();
                    break;
                case 'r':
                case 'R':
                    this.restartScenario();
                    break;
            }
        });
    }

    // ==========================================
    // GESTION DES SCÉNARIOS
    // ==========================================

    /**
     * Ajoute un scénario
     * @param {Object} scenario Configuration du scénario
     */
    addScenario(scenario) {
        const validatedScenario = {
            id: scenario.id || `scenario-${this.scenarios.length}`,
            title: scenario.title || 'Scénario sans titre',
            description: scenario.description || '',
            level: scenario.level || 'basic', // basic, intermediate, advanced
            steps: scenario.steps || [],
            realtimeControls: scenario.realtimeControls || [],
            onEnter: scenario.onEnter || null,
            onExit: scenario.onExit || null
        };

        this.scenarios.push(validatedScenario);
        this.updateScenarioList();

        return validatedScenario.id;
    }

    /**
     * Définit plusieurs scénarios à la fois
     */
    setScenarios(scenarios) {
        this.scenarios = [];
        scenarios.forEach(s => this.addScenario(s));
    }

    /**
     * Met à jour l'affichage de la liste des scénarios
     */
    updateScenarioList() {
        if (!this.scenarioList) return;

        this.scenarioList.innerHTML = '';

        this.scenarios.forEach((scenario, index) => {
            const item = document.createElement('li');
            item.className = 'scenario-item';
            item.setAttribute('data-scenario-id', scenario.id);

            const badgeClass = {
                basic: 'badge-basic',
                intermediate: 'badge-intermediate',
                advanced: 'badge-advanced'
            }[scenario.level] || 'badge-basic';

            const levelLabel = {
                basic: 'Basique',
                intermediate: 'Intermédiaire',
                advanced: 'Avancé'
            }[scenario.level] || 'Basique';

            item.innerHTML = `
                <div class="scenario-item-title">${scenario.title}</div>
                <div class="scenario-item-desc">${scenario.description}</div>
                <span class="scenario-item-badge ${badgeClass}">${levelLabel}</span>
            `;

            item.addEventListener('click', () => this.selectScenario(scenario.id));

            this.scenarioList.appendChild(item);
        });
    }

    /**
     * Sélectionne et démarre un scénario
     */
    selectScenario(scenarioId) {
        const scenario = this.scenarios.find(s => s.id === scenarioId);
        if (!scenario) return;

        // Mettre à jour l'UI
        document.querySelectorAll('.scenario-item').forEach(item => {
            item.classList.toggle('active', item.getAttribute('data-scenario-id') === scenarioId);
        });

        this.currentScenario = scenario;
        this.currentStepIndex = 0;

        // Callback d'entrée
        if (scenario.onEnter) {
            scenario.onEnter();
        }

        // Configurer les contrôles en temps réel
        this.setupRealtimeControls(scenario.realtimeControls);

        // Afficher la première étape
        this.showStep(0);

        // Démarrer l'animation du scénario
        this.startScenarioAnimation();
    }

    // ==========================================
    // NAVIGATION DANS LES ÉTAPES
    // ==========================================

    showStep(index) {
        if (!this.currentScenario) return;

        const steps = this.currentScenario.steps;
        if (index < 0 || index >= steps.length) return;

        this.currentStepIndex = index;
        const step = steps[index];

        // Mettre à jour l'affichage
        this.updateStepDisplay(step);

        // Mettre à jour les boutons
        if (this.prevBtn) {
            this.prevBtn.disabled = index === 0;
        }
        if (this.nextBtn) {
            this.nextBtn.disabled = index === steps.length - 1;
        }

        // Exécuter l'animation de l'étape
        if (step.animation) {
            this.executeStepAnimation(step);
        }

        // Callback de l'étape
        if (step.onEnter) {
            step.onEnter();
        }
    }

    updateStepDisplay(step) {
        // Numéro de l'étape
        if (this.stepDisplay) {
            this.stepDisplay.textContent = `Étape ${this.currentStepIndex + 1}`;
        }
        if (this.totalDisplay) {
            this.totalDisplay.textContent = this.currentScenario.steps.length;
        }

        // Description
        if (this.scenarioDescription) {
            this.scenarioDescription.innerHTML = `
                <div class="step-title">${step.title || ''}</div>
                <div class="step-content">${step.description || ''}</div>
            `;
        }
    }

    nextStep() {
        if (!this.currentScenario) return;

        const nextIndex = this.currentStepIndex + 1;
        if (nextIndex < this.currentScenario.steps.length) {
            this.showStep(nextIndex);
        }
    }

    previousStep() {
        if (!this.currentScenario) return;

        const prevIndex = this.currentStepIndex - 1;
        if (prevIndex >= 0) {
            this.showStep(prevIndex);
        }
    }

    restartScenario() {
        if (this.currentScenario) {
            this.showStep(0);
        }
    }

    // ==========================================
    // ANIMATIONS DES ÉTAPES
    // ==========================================

    executeStepAnimation(step) {
        if (!step.animation) return;

        const anim = step.animation;

        // Configurer les paramètres initiaux
        if (anim.initialParams) {
            Object.assign(this.realtimeParams, anim.initialParams);
        }

        // Exécuter les animations séquentielles ou parallèles
        if (anim.sequence) {
            this.animation.sequence(anim.sequence);
        } else if (anim.parallel) {
            this.animation.parallel(anim.parallel);
        } else if (anim.animate) {
            this.animation.animate(anim.animate);
        }
    }

    startScenarioAnimation() {
        if (!this.scenarioRenderer) return;

        // Utiliser un renderer et animation dédiés pour les scénarios
        const scenarioAnimation = new AnimationCore(this.scenarioRenderer);

        scenarioAnimation.onUpdate = (dt, elapsed) => {
            this.updateScenarioState(dt, elapsed);
        };

        scenarioAnimation.onRender = (renderer) => {
            this.renderScenario(renderer);
        };

        scenarioAnimation.start();
        this.scenarioAnimation = scenarioAnimation;
    }

    updateScenarioState(deltaTime, elapsedTime) {
        // Mise à jour de l'état du scénario
        // À surcharger dans AnimationLogic si besoin
    }

    renderScenario(renderer) {
        // Rendu du scénario
        // Appeler la méthode de rendu d'AnimationLogic avec les paramètres du scénario
        if (typeof AnimationLogic !== 'undefined' && AnimationLogic.renderScenario) {
            AnimationLogic.renderScenario(renderer, this.currentStepIndex, this.realtimeParams);
        } else if (typeof AnimationLogic !== 'undefined' && AnimationLogic.render) {
            AnimationLogic.render(renderer);
        }
    }

    // ==========================================
    // CONTRÔLES EN TEMPS RÉEL
    // ==========================================

    setupRealtimeControls(controls) {
        const container = document.querySelector('.scenario-realtime-controls');
        if (!container || !controls || controls.length === 0) {
            if (container) container.style.display = 'none';
            return;
        }

        container.style.display = 'block';
        container.innerHTML = '<h4>Ajustements</h4>';

        controls.forEach(ctrl => {
            const div = document.createElement('div');
            div.className = 'realtime-control';

            switch (ctrl.type) {
                case 'range':
                    div.innerHTML = `
                        <label>${ctrl.label}</label>
                        <input type="range"
                               id="rt-${ctrl.param}"
                               min="${ctrl.min || 0}"
                               max="${ctrl.max || 100}"
                               step="${ctrl.step || 1}"
                               value="${ctrl.default || 50}">
                    `;
                    container.appendChild(div);

                    const rangeInput = div.querySelector('input');
                    this.realtimeParams[ctrl.param] = ctrl.default || 50;
                    rangeInput.addEventListener('input', () => {
                        this.realtimeParams[ctrl.param] = parseFloat(rangeInput.value);
                    });
                    break;

                case 'checkbox':
                    div.innerHTML = `
                        <label class="checkbox-label">
                            <input type="checkbox" id="rt-${ctrl.param}" ${ctrl.default ? 'checked' : ''}>
                            <span>${ctrl.label}</span>
                        </label>
                    `;
                    container.appendChild(div);

                    const checkbox = div.querySelector('input');
                    this.realtimeParams[ctrl.param] = ctrl.default || false;
                    checkbox.addEventListener('change', () => {
                        this.realtimeParams[ctrl.param] = checkbox.checked;
                    });
                    break;
            }
        });
    }

    // ==========================================
    // CONTRÔLE LECTURE/PAUSE
    // ==========================================

    togglePlayPause() {
        if (this.scenarioAnimation) {
            if (this.isPaused) {
                this.scenarioAnimation.resume();
                this.isPaused = false;
            } else {
                this.scenarioAnimation.pause();
                this.isPaused = true;
            }
        }
    }

    setSpeed(speed) {
        // 0.5x, 1x, 2x
        if (this.scenarioAnimation) {
            // Ajuster le timing des animations
        }
    }

    // ==========================================
    // UTILITAIRES
    // ==========================================

    getCurrentScenario() {
        return this.currentScenario;
    }

    getCurrentStep() {
        if (!this.currentScenario) return null;
        return this.currentScenario.steps[this.currentStepIndex];
    }

    getRealtimeParams() {
        return { ...this.realtimeParams };
    }
}

// ==========================================
// DÉFINITION DES SCÉNARIOS
// ==========================================

/**
 * SCÉNARIOS À DÉFINIR ICI
 * Ajouter vos scénarios dans cette constante
 */
const SCENARIOS = [
    /*
    // Exemple de scénario basique
    {
        id: 'intro',
        title: 'Introduction',
        description: 'Découverte des concepts de base',
        level: 'basic',
        steps: [
            {
                title: 'Étape 1 - Présentation',
                description: 'Voici le repère orthonormé avec les axes <span class="math-highlight">x</span> et <span class="math-highlight">y</span>.',
                animation: {
                    initialParams: { showGrid: true, showAxes: true }
                }
            },
            {
                title: 'Étape 2 - Un point',
                description: 'Plaçons le point <span class="math-highlight">A(2, 3)</span> dans le repère.',
                animation: {
                    animate: {
                        from: { x: 0, y: 0 },
                        to: { x: 2, y: 3 },
                        duration: 1500,
                        easing: 'easeOutQuad'
                    }
                }
            }
        ],
        realtimeControls: [
            {
                type: 'range',
                param: 'pointSize',
                label: 'Taille du point',
                min: 3,
                max: 15,
                default: 8
            }
        ]
    },

    // Exemple de scénario intermédiaire
    {
        id: 'vectors',
        title: 'Les vecteurs',
        description: 'Construction et manipulation de vecteurs',
        level: 'intermediate',
        steps: [
            // ...
        ]
    },

    // Exemple de scénario avancé
    {
        id: 'transformations',
        title: 'Transformations',
        description: 'Rotations, translations, homothéties',
        level: 'advanced',
        steps: [
            // ...
        ]
    }
    */
];

// Export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { ScenarioManager, SCENARIOS };
}

    </script>
</body>
</html>
