{
  "source": {
    "pdf": "2STHR.pdf",
    "page": 12,
    "text_length": 2487
  },
  "extraction": {
    "date": "2026-01-02T12:00:00Z",
    "agent": "bo-competence-extractor",
    "version": "2.0",
    "status": "completed"
  },
  "competences": [
    {
      "code": "2STH-PR-601",
      "intitule": "Definir un echantillon aleatoire de taille n pour une epreuve de Bernoulli",
      "fingerprint": "definir_echantillon_aleatoire_bernoulli",
      "niveau": "2STH",
      "domaine": "PROBABILITES",
      "sous_domaine": "Echantillonnage",
      "type": "contenu",
      "description_detaillee": "Comprendre la notion d'echantillon aleatoire de taille n dans le contexte d'une epreuve de Bernoulli de parametre p donne",
      "formulation_bo": "Echantillon aleatoire de taille n pour une epreuve de Bernoulli de parametre p donne.",
      "connaissances_associees": ["epreuve de Bernoulli", "parametre p", "notion d'echantillon"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-PR-602",
      "intitule": "Enoncer la loi des grands nombres en version vulgarisee",
      "fingerprint": "enoncer_loi_grands_nombres_vulgarisee",
      "niveau": "2STH",
      "domaine": "PROBABILITES",
      "sous_domaine": "Echantillonnage",
      "type": "contenu",
      "description_detaillee": "Connaitre et formuler la version vulgarisee de la loi des grands nombres : lorsque n est grand, sauf exception, la frequence observee est proche de la probabilite",
      "formulation_bo": "Version vulgarisee de la loi des grands nombres : Lorsque n est grand, sauf exception, la frequence observee est proche de la probabilite.",
      "connaissances_associees": ["frequence", "probabilite", "notion de limite"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-PR-603",
      "intitule": "Expliquer le principe d'estimation d'une probabilite par une frequence observee",
      "fingerprint": "expliquer_estimation_probabilite_frequence",
      "niveau": "2STH",
      "domaine": "PROBABILITES",
      "sous_domaine": "Echantillonnage",
      "type": "contenu",
      "description_detaillee": "Comprendre le principe d'estimation d'une probabilite ou d'une proportion dans une population par une frequence observee sur un echantillon",
      "formulation_bo": "Principe de l'estimation d'une probabilite, ou d'une proportion dans une population, par une frequence observee sur un echantillon.",
      "connaissances_associees": ["echantillon", "frequence", "proportion", "population"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-604",
      "intitule": "Simuler la loi des grands nombres avec Python",
      "fingerprint": "simuler_loi_grands_nombres_python",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Simulation",
      "type": "capacite",
      "description_detaillee": "Ecrire et executer un programme Python permettant de simuler la loi des grands nombres",
      "formulation_bo": "Simuler la loi des grands nombres avec Python ou sur tableur.",
      "connaissances_associees": ["loi des grands nombres", "Python", "boucles", "fonctions aleatoires"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-605",
      "intitule": "Simuler la loi des grands nombres avec un tableur",
      "fingerprint": "simuler_loi_grands_nombres_tableur",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Simulation",
      "type": "capacite",
      "description_detaillee": "Utiliser un tableur pour simuler la loi des grands nombres",
      "formulation_bo": "Simuler la loi des grands nombres avec Python ou sur tableur.",
      "connaissances_associees": ["loi des grands nombres", "tableur", "formules aleatoires"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-606",
      "intitule": "Simuler N echantillons de taille n selon une loi de Bernoulli",
      "fingerprint": "simuler_n_echantillons_bernoulli",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Simulation",
      "type": "capacite",
      "description_detaillee": "Creer une simulation generant N echantillons de taille n suivant une loi de Bernoulli de parametre p",
      "formulation_bo": "Simuler N echantillons de taille n selon une loi de Bernoulli de parametre p.",
      "connaissances_associees": ["echantillon", "loi de Bernoulli", "boucles imbriquees"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-PR-607",
      "intitule": "Observer la proportion des cas ou l'intervalle de fluctuation contient p",
      "fingerprint": "observer_proportion_intervalle_fluctuation_contient_p",
      "niveau": "2STH",
      "domaine": "PROBABILITES",
      "sous_domaine": "Echantillonnage",
      "type": "capacite",
      "description_detaillee": "A partir de N echantillons simules, observer la proportion des cas ou l'intervalle [f - 1/sqrt(n), f + 1/sqrt(n)] contient le parametre p",
      "formulation_bo": "Observer la proportion des cas ou l'intervalle [f - 1/sqrt(n), f + 1/sqrt(n)] contient p.",
      "connaissances_associees": ["intervalle de fluctuation", "frequence", "parametre p"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-608",
      "intitule": "Lire une fonction Python renvoyant le nombre de succes dans un echantillon de Bernoulli",
      "fingerprint": "lire_fonction_python_nombre_succes_bernoulli",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Lecture de code",
      "type": "algorithme",
      "description_detaillee": "Lire et comprendre une fonction Python qui renvoie le nombre de succes dans un echantillon de taille n pour une epreuve de Bernoulli de parametre p",
      "formulation_bo": "Lire et comprendre une fonction Python renvoyant le nombre ou la frequence de succes dans un echantillon de taille n pour une epreuve de Bernoulli de parametre p.",
      "connaissances_associees": ["fonction Python", "Bernoulli", "comptage"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-609",
      "intitule": "Lire une fonction Python renvoyant la frequence de succes dans un echantillon de Bernoulli",
      "fingerprint": "lire_fonction_python_frequence_succes_bernoulli",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Lecture de code",
      "type": "algorithme",
      "description_detaillee": "Lire et comprendre une fonction Python qui renvoie la frequence de succes dans un echantillon de taille n pour une epreuve de Bernoulli de parametre p",
      "formulation_bo": "Lire et comprendre une fonction Python renvoyant le nombre ou la frequence de succes dans un echantillon de taille n pour une epreuve de Bernoulli de parametre p.",
      "connaissances_associees": ["fonction Python", "Bernoulli", "frequence", "division"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-610",
      "intitule": "Definir la notion de fonction en programmation",
      "fingerprint": "definir_fonction_programmation",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Concepts fondamentaux",
      "type": "contenu",
      "description_detaillee": "Comprendre la notion de fonction comme element essentiel de la demarche algorithmique",
      "formulation_bo": "la notion de fonction",
      "connaissances_associees": ["definition de fonction", "parametres", "valeur de retour"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-611",
      "intitule": "Comprendre la programmation comme production d'un texte dans un langage informatique",
      "fingerprint": "comprendre_programmation_texte_langage",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Concepts fondamentaux",
      "type": "contenu",
      "description_detaillee": "Apprehender la programmation comme la production d'un texte structure dans un langage informatique",
      "formulation_bo": "la programmation comme production d'un texte dans un langage informatique",
      "connaissances_associees": ["syntaxe", "langage de programmation"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-612",
      "intitule": "Decrire un algorithme en langage naturel",
      "fingerprint": "decrire_algorithme_langage_naturel",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Expression algorithmique",
      "type": "capacite",
      "description_detaillee": "Formuler un algorithme en utilisant le langage naturel de maniere claire et structuree",
      "formulation_bo": "decrire des algorithmes en langage naturel ou dans un langage de programmation",
      "connaissances_associees": ["algorithme", "structure sequentielle", "pseudo-code"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-613",
      "intitule": "Decrire un algorithme dans un langage de programmation",
      "fingerprint": "decrire_algorithme_langage_programmation",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Expression algorithmique",
      "type": "capacite",
      "description_detaillee": "Traduire un algorithme en code dans un langage de programmation (Python)",
      "formulation_bo": "decrire des algorithmes en langage naturel ou dans un langage de programmation",
      "connaissances_associees": ["syntaxe Python", "traduction algorithme-code"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-614",
      "intitule": "Realiser un algorithme a l'aide d'un programme Python",
      "fingerprint": "realiser_algorithme_programme_python",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Programmation",
      "type": "capacite",
      "description_detaillee": "Implementer un algorithme en ecrivant un programme simple en Python",
      "formulation_bo": "en realiser quelques-uns a l'aide d'un programme simple ecrit dans un langage de programmation textuel",
      "connaissances_associees": ["Python", "syntaxe", "execution de programme"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-615",
      "intitule": "Interpreter un algorithme complexe",
      "fingerprint": "interpreter_algorithme_complexe",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Lecture de code",
      "type": "capacite",
      "description_detaillee": "Analyser et comprendre le fonctionnement d'un algorithme plus complexe donne",
      "formulation_bo": "interpreter, completer ou modifier des algorithmes plus complexes",
      "connaissances_associees": ["lecture de code", "trace d'execution", "analyse"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-616",
      "intitule": "Completer un algorithme complexe",
      "fingerprint": "completer_algorithme_complexe",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Programmation",
      "type": "capacite",
      "description_detaillee": "Completer un algorithme partiellement ecrit pour le rendre fonctionnel",
      "formulation_bo": "interpreter, completer ou modifier des algorithmes plus complexes",
      "connaissances_associees": ["analyse de code", "completion", "logique algorithmique"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-617",
      "intitule": "Modifier un algorithme complexe",
      "fingerprint": "modifier_algorithme_complexe",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Programmation",
      "type": "capacite",
      "description_detaillee": "Adapter un algorithme existant pour repondre a un nouveau besoin ou corriger un dysfonctionnement",
      "formulation_bo": "interpreter, completer ou modifier des algorithmes plus complexes",
      "connaissances_associees": ["modification de code", "adaptation", "debugging"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-618",
      "intitule": "Passer d'un algorithme en langage naturel a une programmation Python",
      "fingerprint": "traduire_langage_naturel_vers_python",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Traduction",
      "type": "capacite",
      "description_detaillee": "Traduire un algorithme ecrit en langage naturel en code Python executable",
      "formulation_bo": "Les eleves sont entraines a passer de l'ecriture d'un algorithme en langage naturel a une programmation en Python et inversement.",
      "connaissances_associees": ["langage naturel", "syntaxe Python", "traduction"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-619",
      "intitule": "Passer d'un programme Python a un algorithme en langage naturel",
      "fingerprint": "traduire_python_vers_langage_naturel",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Traduction",
      "type": "capacite",
      "description_detaillee": "Reformuler un programme Python en algorithme ecrit en langage naturel",
      "formulation_bo": "Les eleves sont entraines a passer de l'ecriture d'un algorithme en langage naturel a une programmation en Python et inversement.",
      "connaissances_associees": ["lecture Python", "langage naturel", "reformulation"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-620",
      "intitule": "Identifier les variables informatiques de type entier",
      "fingerprint": "identifier_variable_type_entier",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Variables",
      "type": "contenu",
      "description_detaillee": "Connaitre et identifier les variables de type entier en programmation",
      "formulation_bo": "Variables informatiques de type entier, flottant, chaine de caractere.",
      "connaissances_associees": ["type entier", "int", "variable"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-621",
      "intitule": "Identifier les variables informatiques de type flottant",
      "fingerprint": "identifier_variable_type_flottant",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Variables",
      "type": "contenu",
      "description_detaillee": "Connaitre et identifier les variables de type flottant (nombres decimaux) en programmation",
      "formulation_bo": "Variables informatiques de type entier, flottant, chaine de caractere.",
      "connaissances_associees": ["type flottant", "float", "variable"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-622",
      "intitule": "Identifier les variables informatiques de type chaine de caracteres",
      "fingerprint": "identifier_variable_type_chaine",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Variables",
      "type": "contenu",
      "description_detaillee": "Connaitre et identifier les variables de type chaine de caracteres en programmation",
      "formulation_bo": "Variables informatiques de type entier, flottant, chaine de caractere.",
      "connaissances_associees": ["type string", "str", "variable"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-623",
      "intitule": "Utiliser l'affectation dans un algorithme en langage naturel",
      "fingerprint": "utiliser_affectation_langage_naturel",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Instructions elementaires",
      "type": "capacite",
      "description_detaillee": "Utiliser le symbole fleche gauche pour l'affectation dans un algorithme ecrit en langage naturel",
      "formulation_bo": "Affectation (on utilise le symbole fleche pour designer l'affectation dans un algorithme ecrit en langage naturel, le symbole = en Python).",
      "connaissances_associees": ["affectation", "fleche gauche", "variable"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-624",
      "intitule": "Utiliser l'affectation en Python",
      "fingerprint": "utiliser_affectation_python",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Instructions elementaires",
      "type": "capacite",
      "description_detaillee": "Utiliser le symbole = pour l'affectation en Python",
      "formulation_bo": "Affectation (on utilise le symbole fleche pour designer l'affectation dans un algorithme ecrit en langage naturel, le symbole = en Python).",
      "connaissances_associees": ["affectation", "symbole egal", "Python"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-625",
      "intitule": "Ecrire une sequence d'instructions",
      "fingerprint": "ecrire_sequence_instructions",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Instructions elementaires",
      "type": "capacite",
      "description_detaillee": "Organiser des instructions en sequence pour former un algorithme",
      "formulation_bo": "Sequence d'instructions.",
      "connaissances_associees": ["instruction", "sequence", "ordre d'execution"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-626",
      "intitule": "Utiliser une instruction conditionnelle",
      "fingerprint": "utiliser_instruction_conditionnelle",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Structures de controle",
      "type": "capacite",
      "description_detaillee": "Utiliser les instructions conditionnelles (if, else) pour orienter l'execution d'un programme",
      "formulation_bo": "Instruction conditionnelle.",
      "connaissances_associees": ["if", "else", "condition", "booleen"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-627",
      "intitule": "Utiliser une boucle bornee (for)",
      "fingerprint": "utiliser_boucle_for",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Structures de controle",
      "type": "capacite",
      "description_detaillee": "Utiliser la boucle for pour repeter un bloc d'instructions un nombre determine de fois",
      "formulation_bo": "Boucle bornee (for), boucle non bornee (while).",
      "connaissances_associees": ["for", "range", "iteration", "compteur"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    },
    {
      "code": "2STH-AG-628",
      "intitule": "Utiliser une boucle non bornee (while)",
      "fingerprint": "utiliser_boucle_while",
      "niveau": "2STH",
      "domaine": "ALGORITHMIQUE",
      "sous_domaine": "Structures de controle",
      "type": "capacite",
      "description_detaillee": "Utiliser la boucle while pour repeter un bloc d'instructions tant qu'une condition est verifiee",
      "formulation_bo": "Boucle bornee (for), boucle non bornee (while).",
      "connaissances_associees": ["while", "condition d'arret", "iteration"],
      "source": {"pdf": "2STHR.pdf", "page": 12}
    }
  ],
  "summary": {
    "total": 28,
    "by_type": {
      "contenu": 8,
      "capacite": 18,
      "algorithme": 2
    },
    "by_domaine": {
      "PROBABILITES": 4,
      "ALGORITHMIQUE": 24
    },
    "fingerprints": [
      "definir_echantillon_aleatoire_bernoulli",
      "enoncer_loi_grands_nombres_vulgarisee",
      "expliquer_estimation_probabilite_frequence",
      "simuler_loi_grands_nombres_python",
      "simuler_loi_grands_nombres_tableur",
      "simuler_n_echantillons_bernoulli",
      "observer_proportion_intervalle_fluctuation_contient_p",
      "lire_fonction_python_nombre_succes_bernoulli",
      "lire_fonction_python_frequence_succes_bernoulli",
      "definir_fonction_programmation",
      "comprendre_programmation_texte_langage",
      "decrire_algorithme_langage_naturel",
      "decrire_algorithme_langage_programmation",
      "realiser_algorithme_programme_python",
      "interpreter_algorithme_complexe",
      "completer_algorithme_complexe",
      "modifier_algorithme_complexe",
      "traduire_langage_naturel_vers_python",
      "traduire_python_vers_langage_naturel",
      "identifier_variable_type_entier",
      "identifier_variable_type_flottant",
      "identifier_variable_type_chaine",
      "utiliser_affectation_langage_naturel",
      "utiliser_affectation_python",
      "ecrire_sequence_instructions",
      "utiliser_instruction_conditionnelle",
      "utiliser_boucle_for",
      "utiliser_boucle_while"
    ]
  }
}
